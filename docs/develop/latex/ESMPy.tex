%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{ESMPy Documentation}
\date{Jul 28, 2020}
\release{8.1.0 beta snapshot}
\author{ESMPy}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Welcome to ESMPy - The ESMF Python Interface!


\chapter{Overview}
\label{\detokenize{intro:module-ESMF}}\label{\detokenize{intro:overview}}\label{\detokenize{intro::doc}}\index{ESMF (module)@\spxentry{ESMF}\spxextra{module}}
ESMPy is a Python interface to the Earth System Modeling Framework (ESMF) 
regridding utility. ESMF is software for
building and coupling weather, climate, and related models. ESMF has a robust,
parallel and scalable remapping package, used to generate remapping weights.
It can handle a wide variety of grids and options: logically rectangular grids,
unstructured meshes and sets of unconnected points; regional or global grids;
2D or 3D; and pole and masking options. ESMF also has capabilities to read grid
information from NetCDF files in a variety of formats, including the
\sphinxhref{http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html}{Climate and Forecast (CF) V1.6 (a.k.a GridSpec)},
\sphinxhref{https://github.com/ugrid-conventions/ugrid-conventions}{UGRID},
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03028200000000000000}{ESMF Unstructured}
and
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03028100000000000000}{SCRIP}
conventions.

ESMPy provides a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} to represent single-tile logically
rectangular coordinate data, a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} for unstructured 
coordinates, and a {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} for collections of
unconnected points like observational data streams.
ESMPy supports bilinear, nearest neighbor, higher order patch recovery, 
first-order conservative and second-order conservative regridding. There is 
also an option to ignore unmapped destination points, mask out points on either
the source or destination, choose straight line or great circle paths when using
spherical coordinates and extrapolate data to points outside of the destination
domain. Regridding on the sphere takes place in 3D Cartesian space, so the pole
problem is not an issue as it commonly is with many Earth system grid remapping
softwares. {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} and {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} 
objects can be created in 2D or 3D space, and 3D conservative regridding is 
fully supported.

Regridding, also called remapping or interpolation, is the process of changing
the grid underneath field data values while preserving the qualities of the
original data. Different kinds of transformations are appropriate for
different problems. Regridding may be needed when communicating data between
Earth system modeling components such as land and atmosphere, or between
different data sets to support analysis or visualization.

Regridding can be broken into two stages. The first stage is generation of an
interpolation weight matrix that describes how points in the source grid
contribute to points in the destination grid. The second stage is the
multiplication of values on the source grid by the interpolation weight matrix
to produce the appropriate values on the destination grid. ESMPy provides
access to both stages through two separate interfaces.

There are many different interpolation methods, suitable for different problems.
In ESMPy, the basic bilinear option is a two dimensional variant of linear 
interpolation. The higher order patch recovery is a second degree polynomial 
regridding method, which uses a least squares algorithm to calculate the 
polynomial. This method gives better derivatives in the resulting destination 
field than the bilinear. There are two nearest-neighbor methods which map the 
points from one grid to the nearest corresponding point on the other grid, from
either source to destination or vice versa. These are useful for extrapolation 
or categorical fields.

The first-order conservative regridding is a method designed to preserve the 
integral of the field across the interpolation from source to destination.  It 
uses the proportion of the area of the overlapping source and destination cells
to determine appropriate weights. The second-order conservative method also 
preserves the integral, but uses the source gradient to give a smoother result 
than the first-order conservative. All of these methods can be broken down to a
simple sparse matrix multiplication operation between interpolation weights and
data values.


\chapter{Important Links}
\label{\detokenize{intro:important-links}}
The \sphinxhref{http://www.earthsystemcog.org/projects/esmpy/}{ESMPy home page} has all of the
latest information on the ESMPy project including release notes, known
bugs, supported platforms, and download information.

Please see the \sphinxhref{http://www.earthsystemmodeling.org}{ESMF home page}
for more information on ESMF in general.

\sphinxhref{http://earthsystemcog.org/site\_media/projects/esmf/pres\_1105\_goessp\_oehmke.ppt}{Fast Parallel Grid Remapping for Unstructured and Structured Grids}
gives a nice overview of the ESMF remapping functionality.

The \sphinxhref{https://www.earthsystemcog.org/projects/esmf/regridding\_8\_0\_0}{ESMF Regridding Status}
page gives a good overview of the functionality that is available through
various interfaces to ESMF regridding.

The \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03020000000000000000}{ESMF\_RegridWeightGen application}
is a command-line version of the functionality that is available through ESMPy.

Please contact \sphinxhref{mailto:esmf\_support@ucar.edu}{esmf\_support@ucar.edu} with any questions or problems.


\chapter{Installation}
\label{\detokenize{install:installation}}\label{\detokenize{install::doc}}

\section{Requirements}
\label{\detokenize{install:requirements}}
The following packages are \sphinxstyleemphasis{required} to work with ESMPy:
\begin{itemize}
\item {} 
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_usrdoc/node9.html}{ESMF installation}

\item {} 
\sphinxhref{http://python.org/}{python}

\item {} 
\sphinxhref{http://www.numpy.org/}{numpy}

\end{itemize}

The following packages are \sphinxstyleemphasis{optional}:
\begin{itemize}
\item {} \begin{description}
\item[{ESMF installation with NetCDF - required to create {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grids}}}}} and {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}} from file}] \leavevmode\begin{itemize}
\item {} 
NetCDF must be built as a shared library for ESMPy installation to succeed

\end{itemize}

\end{description}

\item {} 
\sphinxhref{http://mpi4py.scipy.org/}{mpi4py}- python bindings to MPI, needed to run some of the parallel regridding examples

\item {} 
\sphinxhref{https://nose.readthedocs.org/en/latest/}{nose} - for nose testing

\end{itemize}


\section{Getting the code}
\label{\detokenize{install:getting-the-code}}
The \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_usrdoc/}{ESMF User’s Guide}
contains information on building and installing ESMF.
The \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/}{ESMF Reference Manual}
contains information on the architecture of ESMF, example code, and details of the API (Application Programming
Interface).

Instructions on how to download the ESMPy code can be found at the \sphinxhref{http://www.earthsystemcog.org/projects/esmpy/releases}{ESMPy Download page}.


\subsection{Anaconda Packages}
\label{\detokenize{install:anaconda-packages}}
ESMPy conda packages are available through the conda-forge channel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{esmpy} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{n}{esmpy}
\end{sphinxVerbatim}

Specific versions of the conda package can be installed like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{esmpy} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{n}{esmpy}\PYG{o}{=}\PYG{l+m+mf}{8.0}\PYG{o}{.}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\section{Installing ESMPy from Source}
\label{\detokenize{install:installing-esmpy-from-source}}
When installing from source, ESMPy requires a pointer to a file named esmf.mk
that is generated during an ESMF installation.  The path of this file is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{ESMF\PYGZus{}INSTALL\PYGZus{}DIR}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{\PYGZlt{}}\PYG{n}{g}\PYG{o}{\PYGZlt{}}\PYG{o+ow}{or}\PYG{o}{\PYGZgt{}}\PYG{n}{O}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{o}{\PYGZlt{}}\PYG{n}{platform}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{esmf}\PYG{o}{.}\PYG{n}{mk}
\end{sphinxVerbatim}

If the \sphinxcode{\sphinxupquote{ESMFMKFILE}} flag is set when building ESMPy then it will not need to be
referenced again.  If not, an environment variable of the same name must be set
with the path to the esmf.mk file every time a new shell is initiated.

ESMPy can be installed in a custom location using the
\sphinxcode{\sphinxupquote{-{-}prefix}}, \sphinxcode{\sphinxupquote{-{-}home}}, or \sphinxcode{\sphinxupquote{-{-}install-base}} flags to the install command.  If this
is done, then this location needs to be added to the \sphinxcode{\sphinxupquote{PYTHONPATH}} environment
variable every time a new shell is initiated.  If a
custom install location is not specified, ESMPy will be installed in the
standard Python package installation directory on that particular machine.

An installation of ESMPy in the default location for Python packages can be done
with the following command issued from the top level ESMPy directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{ESMFMKFILE}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{DIR\PYGZus{}TO\PYGZus{}esmf}\PYG{o}{.}\PYG{n}{mk}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{esmf}\PYG{o}{.}\PYG{n}{mk} \PYG{n}{install}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
custom install location:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{ESMFMKFILE}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{DIR\PYGZus{}TO\PYGZus{}esmf}\PYG{o}{.}\PYG{n}{mk}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{esmf}\PYG{o}{.}\PYG{n}{mk}

\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{prefix}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{custom\PYGZus{}install\PYGZus{}location}\PYG{o}{\PYGZgt{}}

\PYG{n}{setenv} \PYG{n}{PYTHONPATH} \PYG{o}{\PYGZlt{}}\PYG{n}{custom\PYGZus{}install\PYGZus{}location}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYGZbs{}\PYG{o}{*}\PYG{o}{/}\PYG{n}{site\PYGZus{}packages}
\end{sphinxVerbatim}

Please contact \sphinxhref{mailto:esmf\_support@ucar.edu}{esmf\_support@ucar.edu} with any questions.


\section{Importing ESMPy}
\label{\detokenize{install:importing-esmpy}}
To use ESMPy in an external program, import it with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}
\end{sphinxVerbatim}


\section{Validation}
\label{\detokenize{install:validation}}
The ESMPy testing is done with the nose package, both in serial and
parallel.  The nose commands are wrapped in the following ESMPy targets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test}

\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test\PYGZus{}examples}

\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test\PYGZus{}regrid\PYGZus{}from\PYGZus{}file}

\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test\PYGZus{}parallel}

\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test\PYGZus{}examples\PYGZus{}parallel}

\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test\PYGZus{}regrid\PYGZus{}from\PYGZus{}file\PYGZus{}parallel}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{regrid\_from\_file}} tests can take up a lot of memory and bandwidth.
The \sphinxcode{\sphinxupquote{test\_regrid\_from\_file\_dryrun}} command will simply download the test
files without actually running them (allowing the stress on the machine to
be applied to bandwidth first, and then memory).
\end{sphinxadmonition}

Alternatively, individual tests can be run with nose using the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nosetests} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{test}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nosetests} \PYG{n}{src}\PYG{o}{/}\PYG{n}{ESMF}\PYG{o}{/}\PYG{n}{test}\PYG{o}{/}\PYG{n}{test\PYGZus{}api}\PYG{o}{/}\PYG{n}{test\PYGZus{}regrid}\PYG{o}{.}\PYG{n}{py}\PYG{p}{:}\PYG{n}{TestRegrid}\PYG{o}{.}\PYG{n}{test\PYGZus{}field\PYGZus{}regrid}
\end{sphinxVerbatim}


\section{Limitations}
\label{\detokenize{install:limitations}}
ESMPy doesn’t include many aspects of ESMF, including components, field bundles,
time management, etc.  The limitations listed here are relative
to ESMF offline and integrated regridding capabilities.
\begin{itemize}
\item {} 
ESMPy cannot use an ESMF installation that is built with external LAPACK
support.

\item {} 
Coordinates cannot be retrieved from the elements of a
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. This can affect the ability to set
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} values on a source {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
created from file when using conservative regridding.

\item {} 
Multi-tile {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} support is limited to cubed-sphere
grids created on 6 processors. A cubed-sphere grid can be created on any
number of processors, but only when it is created on 6 processors will the
coordinates be retrievable for the entire object. A
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} created from a cubed-sphere
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cannot be written to file in parallel.

\item {} 
There is no \sphinxcode{\sphinxupquote{FieldBundle}} class, only single {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}}.

\end{itemize}

Testing related:
\begin{itemize}
\item {} 
Nightly regression testing is limited to a small subset of the ESMF test platforms,
including Darwin and Linux running gfortran with openMPI.

\end{itemize}


\chapter{Tutorials}
\label{\detokenize{examples:tutorials}}\label{\detokenize{examples::doc}}

\section{Hello World}
\label{\detokenize{examples:hello-world}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}

\PYG{c+c1}{\PYGZsh{} This call enables debug logging}
\PYG{c+c1}{\PYGZsh{} esmpy = ESMF.Manager(debug=True)}

\PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello ESMPy World from PET (processor) }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\section{Regridding Helper Functions}
\label{\detokenize{examples:regridding-helper-functions}}
The following code snippets demonstrate how to build all of the pieces
necessary to regrid data between {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} built on
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grids}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}}
and {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStreams}}}}}.


\subsection{LocStream Create}
\label{\detokenize{examples:locstream-create}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16}\PYG{p}{(}\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    :param coord\PYGZus{}sys: the coordinate system of the LocStream}
\PYG{l+s+sd}{    :param domask: a boolean to tell whether or not to add a mask}
\PYG{l+s+sd}{    :return: LocStream}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{processor count must be 1 to use this function}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{LocStream}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}

    \PYG{n}{deg\PYGZus{}rad} \PYG{o}{=} \PYG{n}{pi}
    \PYG{k}{if} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{:}
        \PYG{n}{deg\PYGZus{}rad} \PYG{o}{=} \PYG{l+m+mi}{180}

    \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
    \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{locstream}
\end{sphinxVerbatim}


\subsection{LocStream Create Parallel}
\label{\detokenize{examples:locstream-create-parallel}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16\PYGZus{}parallel}\PYG{p}{(}\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    :param coord\PYGZus{}sys: the coordinate system of the LocStream}
\PYG{l+s+sd}{    :param domask: a boolean to tell whether or not to add a mask}
\PYG{l+s+sd}{    :return: LocStream}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{4}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{processor count must be 4 to use this function}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{deg\PYGZus{}rad} \PYG{o}{=} \PYG{n}{pi}
    \PYG{k}{if} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{:}
        \PYG{n}{deg\PYGZus{}rad} \PYG{o}{=} \PYG{l+m+mf}{180.0}

    \PYG{n}{locstream} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{LocStream}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
            \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{LocStream}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
            \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{LocStream}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
            \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{:}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{LocStream}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
        \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
            \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{locstream}
\end{sphinxVerbatim}


\subsection{Create a 2D Grid}
\label{\detokenize{examples:create-a-2d-grid}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{grid\PYGZus{}create\PYGZus{}from\PYGZus{}coordinates}\PYG{p}{(}\PYG{n}{xcoords}\PYG{p}{,} \PYG{n}{ycoords}\PYG{p}{,} \PYG{n}{xcorners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{ycorners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{corners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{doarea}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{ctk}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{TypeKind}\PYG{o}{.}\PYG{n}{R8}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Create a 2 dimensional Grid using the bounds of the x and y coordiantes.}
\PYG{l+s+sd}{    :param xcoords: The 1st dimension or \PYGZsq{}x\PYGZsq{} coordinates at cell centers, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param ycoords: The 2nd dimension or \PYGZsq{}y\PYGZsq{} coordinates at cell centers, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param xcorners: The 1st dimension or \PYGZsq{}x\PYGZsq{} coordinates at cell corners, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param ycorners: The 2nd dimension or \PYGZsq{}y\PYGZsq{} coordinates at cell corners, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param domask: boolean to determine whether to set an arbitrary mask or not}
\PYG{l+s+sd}{    :param doarea: boolean to determine whether to set an arbitrary area values or not}
\PYG{l+s+sd}{    :param ctk: the coordinate typekind}
\PYG{l+s+sd}{    :return: grid}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} create a grid given the number of grid cells in each dimension, the center stagger location is allocated, the}
    \PYG{c+c1}{\PYGZsh{} Cartesian coordinate system and type of the coordinates are specified}
    \PYG{n}{max\PYGZus{}index} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{xcoords}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ycoords}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{max\PYGZus{}index}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{CART}\PYG{p}{,} \PYG{n}{coord\PYGZus{}typekind}\PYG{o}{=}\PYG{n}{ctk}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} set the grid coordinates using numpy arrays, parallel case is handled using grid bounds}
    \PYG{n}{gridXCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}par} \PYG{o}{=} \PYG{n}{xcoords}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridXCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{gridYCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}par} \PYG{o}{=} \PYG{n}{ycoords}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridYCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create grid corners in a slightly different manner to account for the bounds format common in CF\PYGZhy{}like files}
    \PYG{k}{if} \PYG{n}{corners}\PYG{p}{:}
        \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}coords}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{lbx} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}
        \PYG{n}{ubx} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}
        \PYG{n}{lby} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}
        \PYG{n}{uby} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}

        \PYG{n}{gridXCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i0} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ubx} \PYG{o}{\PYGZhy{}} \PYG{n}{lbx} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridXCorner}\PYG{p}{[}\PYG{n}{i0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xcorners}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{n}{lbx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridXCorner}\PYG{p}{[}\PYG{n}{i0} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xcorners}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{n}{lbx}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

        \PYG{n}{gridYCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{uby} \PYG{o}{\PYGZhy{}} \PYG{n}{lby} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridYCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ycorners}\PYG{p}{[}\PYG{n}{i1}\PYG{o}{+}\PYG{n}{lby}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridYCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{i1} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ycorners}\PYG{p}{[}\PYG{n}{i1}\PYG{o}{+}\PYG{n}{lby}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} add an arbitrary mask}
    \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
        \PYG{n}{mask} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}item}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{GridItem}\PYG{o}{.}\PYG{n}{MASK}\PYG{p}{)}
        \PYG{n}{mask}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{mask}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{gridXCenter}\PYG{o}{.}\PYG{n}{any}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)} \PYG{o}{\PYGZam{}}
                      \PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{gridYCenter}\PYG{o}{.}\PYG{n}{any}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{c+c1}{\PYGZsh{} add arbitrary areas values}
    \PYG{k}{if} \PYG{n}{doarea}\PYG{p}{:}
        \PYG{n}{area} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}item}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{GridItem}\PYG{o}{.}\PYG{n}{AREA}\PYG{p}{)}
        \PYG{n}{area}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5.0}

    \PYG{k}{return} \PYG{n}{grid}
\end{sphinxVerbatim}
\end{quote}


\subsection{Create a 3D Grid}
\label{\detokenize{examples:create-a-3d-grid}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{grid\PYGZus{}create\PYGZus{}from\PYGZus{}coordinates\PYGZus{}3d}\PYG{p}{(}\PYG{n}{xcoords}\PYG{p}{,} \PYG{n}{ycoords}\PYG{p}{,} \PYG{n}{zcoords}\PYG{p}{,} \PYG{n}{xcorners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{ycorners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{zcorners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{corners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{doarea}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Create a 3 dimensional Grid using the xcoordinates, ycoordinates and zcoordinates.}
\PYG{l+s+sd}{    :param xcoords: The 1st dimension or \PYGZsq{}x\PYGZsq{} coordinates at cell centers, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param ycoords: The 2nd dimension or \PYGZsq{}y\PYGZsq{} coordinates at cell centers, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param zcoords: The 3rd dimension or \PYGZsq{}z\PYGZsq{} coordinates at cell centers, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param xcorners: The 1st dimension or \PYGZsq{}x\PYGZsq{} coordinates at cell corners, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param ycorners: The 2nd dimension or \PYGZsq{}y\PYGZsq{} coordinates at cell corners, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param zcorners: The 3rd dimension or \PYGZsq{}z\PYGZsq{} coordinates at cell corners, as a Python list or numpy Array}
\PYG{l+s+sd}{    :param corners: boolean to determine whether or not to add corner coordinates to this grid}
\PYG{l+s+sd}{    :param domask: boolean to determine whether to set an arbitrary mask or not}
\PYG{l+s+sd}{    :param doarea: boolean to determine whether to set an arbitrary area values or not}
\PYG{l+s+sd}{    :return: grid}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} create a grid given the number of grid cells in each dimension, the center stagger location is allocated and the}
    \PYG{c+c1}{\PYGZsh{} Cartesian coordinate system is specified}
    \PYG{n}{max\PYGZus{}index} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{xcoords}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ycoords}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{zcoords}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{max\PYGZus{}index}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{CART}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} set the grid coordinates using numpy arrays, parallel case is handled using grid bounds}
    \PYG{n}{gridXCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}par} \PYG{o}{=} \PYG{n}{xcoords}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridXCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{x\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{gridYCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}par} \PYG{o}{=} \PYG{n}{ycoords}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridYCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{gridZCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
    \PYG{n}{z\PYGZus{}par} \PYG{o}{=} \PYG{n}{zcoords}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{z}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER\PYGZus{}VCENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{z}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridZCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{z\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{z\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create grid corners in a slightly different manner to account for the bounds format common in CF\PYGZhy{}like files}
    \PYG{k}{if} \PYG{n}{corners}\PYG{p}{:}
        \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}coords}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{lbx} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}
        \PYG{n}{ubx} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}
        \PYG{n}{lby} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}
        \PYG{n}{uby} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}
        \PYG{n}{lbz} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{[}\PYG{n}{z}\PYG{p}{]}
        \PYG{n}{ubz} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{]}\PYG{p}{[}\PYG{n}{z}\PYG{p}{]}

        \PYG{n}{gridXCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i0} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ubx} \PYG{o}{\PYGZhy{}} \PYG{n}{lbx} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridXCorner}\PYG{p}{[}\PYG{n}{i0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xcorners}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{n}{lbx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridXCorner}\PYG{p}{[}\PYG{n}{i0} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xcorners}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{n}{lbx}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

        \PYG{n}{gridYCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{uby} \PYG{o}{\PYGZhy{}} \PYG{n}{lby} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridYCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ycorners}\PYG{p}{[}\PYG{n}{i1}\PYG{o}{+}\PYG{n}{lby}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridYCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{i1} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ycorners}\PYG{p}{[}\PYG{n}{i1}\PYG{o}{+}\PYG{n}{lby}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

        \PYG{n}{gridZCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER\PYGZus{}VFACE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i2} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ubz} \PYG{o}{\PYGZhy{}} \PYG{n}{lbz} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridZCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{i2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{zcorners}\PYG{p}{[}\PYG{n}{i2}\PYG{o}{+}\PYG{n}{lbz}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridZCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{i2} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{zcorners}\PYG{p}{[}\PYG{n}{i2}\PYG{o}{+}\PYG{n}{lbz}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} add an arbitrary mask}
    \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
        \PYG{n}{mask} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}item}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{GridItem}\PYG{o}{.}\PYG{n}{MASK}\PYG{p}{)}
        \PYG{n}{mask}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{mask}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}} \PYG{n}{gridXCenter}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)} \PYG{o}{\PYGZam{}}
                      \PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}} \PYG{n}{gridYCenter}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)} \PYG{o}{\PYGZam{}}
                      \PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}} \PYG{n}{gridZCenter}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{c+c1}{\PYGZsh{} add arbitrary areas values}
    \PYG{k}{if} \PYG{n}{doarea}\PYG{p}{:}
        \PYG{n}{area} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}item}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{GridItem}\PYG{o}{.}\PYG{n}{AREA}\PYG{p}{)}
        \PYG{n}{area}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5.0}

    \PYG{k}{return} \PYG{n}{grid}
\end{sphinxVerbatim}
\end{quote}


\subsection{Create a Periodic Grid}
\label{\detokenize{examples:create-a-periodic-grid}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{grid\PYGZus{}create\PYGZus{}from\PYGZus{}coordinates\PYGZus{}periodic}\PYG{p}{(}\PYG{n}{longitudes}\PYG{p}{,} \PYG{n}{latitudes}\PYG{p}{,} \PYG{n}{lon\PYGZus{}corners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{lat\PYGZus{}corners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{corners}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Create a 2 dimensional periodic Grid using the \PYGZsq{}longitudes\PYGZsq{} and \PYGZsq{}latitudes\PYGZsq{}.}
\PYG{l+s+sd}{    :param longitudes: longitude coordinate values at cell centers}
\PYG{l+s+sd}{    :param latitudes: latitude coordinate values at cell centers}
\PYG{l+s+sd}{    :param lon\PYGZus{}corners: longitude coordinate values at cell corners}
\PYG{l+s+sd}{    :param lat\PYGZus{}corners: latitude coordinate values at cell corners}
\PYG{l+s+sd}{    :param corners: boolean to determine whether or not to add corner coordinates to this grid}
\PYG{l+s+sd}{    :param domask: boolean to determine whether to set an arbitrary mask or not}
\PYG{l+s+sd}{    :return: grid}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{p}{[}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} create a grid given the number of grid cells in each dimension the center stagger location is allocated}
    \PYG{n}{max\PYGZus{}index} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{longitudes}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{latitudes}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{max\PYGZus{}index}\PYG{p}{,} \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} set the grid coordinates using numpy arrays, parallel case is handled using grid bounds}
    \PYG{n}{gridXCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{)}
    \PYG{n}{lon\PYGZus{}par} \PYG{o}{=} \PYG{n}{longitudes}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridXCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lon\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{n}{lon\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{gridYCenter} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}
    \PYG{n}{lat\PYGZus{}par} \PYG{o}{=} \PYG{n}{latitudes}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]}\PYG{p}{:}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{gridYCenter}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lat\PYGZus{}par}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lat\PYGZus{}par}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create grid corners in a slightly different manner to account for the bounds format common in CF\PYGZhy{}like files}
    \PYG{k}{if} \PYG{n}{corners}\PYG{p}{:}
        \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}coords}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{lbx} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]}
        \PYG{n}{ubx} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]}
        \PYG{n}{lby} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]}
        \PYG{n}{uby} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]}

        \PYG{n}{gridXCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i0} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ubx} \PYG{o}{\PYGZhy{}} \PYG{n}{lbx} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridXCorner}\PYG{p}{[}\PYG{n}{i0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lon\PYGZus{}corners}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{n}{lbx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridXCorner}\PYG{p}{[}\PYG{n}{i0} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lon\PYGZus{}corners}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{n}{lbx}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

        \PYG{n}{gridYCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{uby} \PYG{o}{\PYGZhy{}} \PYG{n}{lby} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gridYCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lat\PYGZus{}corners}\PYG{p}{[}\PYG{n}{i1}\PYG{o}{+}\PYG{n}{lby}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{gridYCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{i1} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lat\PYGZus{}corners}\PYG{p}{[}\PYG{n}{i1}\PYG{o}{+}\PYG{n}{lby}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} add an arbitrary mask}
    \PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
        \PYG{n}{mask} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}item}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{GridItem}\PYG{o}{.}\PYG{n}{MASK}\PYG{p}{)}
        \PYG{n}{mask}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{mask}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{gridXCenter}\PYG{o}{.}\PYG{n}{any}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)} \PYG{o}{\PYGZam{}}
                      \PYG{p}{(}\PYG{l+m+mf}{1.75} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{gridYCenter}\PYG{o}{.}\PYG{n}{any}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.25}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{k}{return} \PYG{n}{grid}
\end{sphinxVerbatim}
\end{quote}


\subsection{Create a 5 Element Mesh}
\label{\detokenize{examples:create-a-5-element-mesh}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mesh\PYGZus{}create\PYGZus{}5}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    PRECONDITIONS: None}
\PYG{l+s+sd}{    POSTCONDITIONS: A 5 element Mesh has been created.    }
\PYG{l+s+sd}{    RETURN VALUES: \PYGZbs{}n Mesh :: mesh \PYGZbs{}n}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{      4.0   31 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 32 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 33}
\PYG{l+s+sd}{            \textbar{}         \textbar{}  22  /   \textbar{}}
\PYG{l+s+sd}{            \textbar{}    21   \textbar{}     /    \textbar{}}
\PYG{l+s+sd}{            \textbar{}         \textbar{}   /  23  \textbar{}}
\PYG{l+s+sd}{      2.0   21 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 22 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 23}
\PYG{l+s+sd}{            \textbar{}         \textbar{}          \textbar{}}
\PYG{l+s+sd}{            \textbar{}    11   \textbar{}    12    \textbar{}}
\PYG{l+s+sd}{            \textbar{}         \textbar{}          \textbar{}}
\PYG{l+s+sd}{      0.0   11 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 12 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 13}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{           0.0       2.0        4.0}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{          Node Ids at corners}
\PYG{l+s+sd}{          Element Ids in centers}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    Note: This mesh is not parallel, it can only be used in serial}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} Two parametric dimensions, and two spatial dimensions}
    \PYG{n}{mesh} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{n}{parametric\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{spatial\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
    
    \PYG{n}{num\PYGZus{}node} \PYG{o}{=} \PYG{l+m+mi}{9}
    \PYG{n}{num\PYGZus{}elem} \PYG{o}{=} \PYG{l+m+mi}{5}
    \PYG{n}{nodeId} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{l+m+mi}{22}\PYG{p}{,}\PYG{l+m+mi}{23}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{33}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{nodeCoord} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 11}
                          \PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 12}
                          \PYG{l+m+mf}{4.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 13}
                          \PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 21}
                          \PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 22}
                          \PYG{l+m+mf}{4.0}\PYG{p}{,}\PYG{l+m+mf}{2.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 23}
                          \PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{4.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 31}
                          \PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{l+m+mf}{4.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} node 32}
                          \PYG{l+m+mf}{4.0}\PYG{p}{,}\PYG{l+m+mf}{4.0}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} node 33}
    \PYG{n}{nodeOwner} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{num\PYGZus{}node}\PYG{p}{)}

    \PYG{n}{elemId} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{l+m+mi}{22}\PYG{p}{,}\PYG{l+m+mi}{23}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{elemType}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{QUAD}\PYG{p}{,}
                       \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{QUAD}\PYG{p}{,}
                       \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{QUAD}\PYG{p}{,}
                       \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{TRI}\PYG{p}{,}
                       \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{TRI}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{elemConn}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} element 11}
                       \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} element 12}
                       \PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} element 21}
                       \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}   \PYG{c+c1}{\PYGZsh{} element 22}
                       \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} element 23}
    \PYG{n}{elemCoord} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,}
                          \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,}
                          \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,}
                          \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{,}
                          \PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}nodes}\PYG{p}{(}\PYG{n}{num\PYGZus{}node}\PYG{p}{,}\PYG{n}{nodeId}\PYG{p}{,}\PYG{n}{nodeCoord}\PYG{p}{,}\PYG{n}{nodeOwner}\PYG{p}{)}

    \PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}elements}\PYG{p}{(}\PYG{n}{num\PYGZus{}elem}\PYG{p}{,}\PYG{n}{elemId}\PYG{p}{,}\PYG{n}{elemType}\PYG{p}{,}\PYG{n}{elemConn}\PYG{p}{,} \PYG{n}{element\PYGZus{}coords}\PYG{o}{=}\PYG{n}{elemCoord}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{mesh}\PYG{p}{,} \PYG{n}{nodeCoord}\PYG{p}{,} \PYG{n}{nodeOwner}\PYG{p}{,} \PYG{n}{elemType}\PYG{p}{,} \PYG{n}{elemConn}\PYG{p}{,} \PYG{n}{elemCoord}
\end{sphinxVerbatim}
\end{quote}


\subsection{Create a Field}
\label{\detokenize{examples:create-a-field}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}field}\PYG{p}{(}\PYG{n}{gml}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{        PRECONDITIONS: An Grid, Mesh or LocStream has been created, and \PYGZsq{}name\PYGZsq{} is a string that}
\PYG{l+s+sd}{                       will be used to initialize the name of a new Field.\PYGZbs{}n}
\PYG{l+s+sd}{        POSTCONDITIONS: A Field has been created.\PYGZbs{}n}
\PYG{l+s+sd}{        RETURN VALUES: \PYGZbs{}n Field :: field \PYGZbs{}n}
\PYG{l+s+sd}{        \PYGZsq{}\PYGZsq{}\PYGZsq{}}
        \PYG{n}{field} \PYG{o}{=} \PYG{n}{Field}\PYG{p}{(}\PYG{n}{gml}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{n}{name}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{field}
\end{sphinxVerbatim}
\end{quote}


\subsection{Initialize an Analytic Field}
\label{\detokenize{examples:initialize-an-analytic-field}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}field\PYGZus{}grid\PYGZus{}periodic}\PYG{p}{(}\PYG{n}{field}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    PRECONDITIONS: A Field has been created as \PYGZsq{}field\PYGZsq{} with a \PYGZsq{}grid\PYGZsq{}}
\PYG{l+s+sd}{                   where coordinates have been set on both }
\PYG{l+s+sd}{                   the center and corner stagger locations. \PYGZbs{}n}
\PYG{l+s+sd}{    POSTCONDITIONS: The \PYGZsq{}field\PYGZsq{} has been initialized to an analytic }
\PYG{l+s+sd}{                    field.\PYGZbs{}n}
\PYG{l+s+sd}{    RETURN VALUES: \PYGZbs{}n Field :: field \PYGZbs{}n}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{DEG2RAD} \PYG{o}{=} \PYG{l+m+mf}{3.141592653589793}\PYG{o}{/}\PYG{l+m+mf}{180.0}

    \PYG{c+c1}{\PYGZsh{} get the coordinate pointers and set the coordinates}
    \PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{field}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
    \PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{field}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}

    \PYG{n}{field}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{DEG2RAD}\PYG{o}{*}\PYG{n}{gridXCoord}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYGZbs{}
                          \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{DEG2RAD}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{90.0} \PYG{o}{\PYGZhy{}} \PYG{n}{gridYCoord}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{field}
\end{sphinxVerbatim}
\end{quote}


\subsection{Run ESMPy Regridding}
\label{\detokenize{examples:run-esmpy-regridding}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{def} \PYG{n+nf}{run\PYGZus{}regridding}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{srcfracfield}\PYG{p}{,} \PYG{n}{dstfracfield}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} This is for documentation. Do not modify.}
        \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{        PRECONDITIONS: Two Fields have been created and a regridding}
\PYG{l+s+sd}{                       operation is desired from \PYGZsq{}srcfield\PYGZsq{} to \PYGZsq{}dstfield\PYGZsq{}.}
\PYG{l+s+sd}{                       The \PYGZsq{}srcfracfield\PYGZsq{} and \PYGZsq{}dstfractfield\PYGZsq{} are Fields}
\PYG{l+s+sd}{                       created to hold the fractions of the source and}
\PYG{l+s+sd}{                       destination fields which contribute to conservative}
\PYG{l+s+sd}{                       regridding.\PYGZbs{}n}
\PYG{l+s+sd}{        POSTCONDITIONS: A regridding operation has set the data on}
\PYG{l+s+sd}{                        \PYGZsq{}dstfield\PYGZsq{}, \PYGZsq{}srcfracfield\PYGZsq{}, and \PYGZsq{}dstfracfield\PYGZsq{}.\PYGZbs{}n}
\PYG{l+s+sd}{        RETURN VALUES: \PYGZbs{}n Field :: dstfield \PYGZbs{}n}
\PYG{l+s+sd}{                          Field :: srcfracfield \PYGZbs{}n}
\PYG{l+s+sd}{                          Field :: dstfracfield \PYGZbs{}n}
\PYG{l+s+sd}{        \PYGZsq{}\PYGZsq{}\PYGZsq{}}
        \PYG{c+c1}{\PYGZsh{} call the regridding functions}
        \PYG{n}{regridSrc2Dst} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,}
                                    \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{CONSERVE}\PYG{p}{,}
                                    \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{ERROR}\PYG{p}{,}
                                    \PYG{n}{src\PYGZus{}frac\PYGZus{}field}\PYG{o}{=}\PYG{n}{srcfracfield}\PYG{p}{,}
                                    \PYG{n}{dst\PYGZus{}frac\PYGZus{}field}\PYG{o}{=}\PYG{n}{dstfracfield}\PYG{p}{)}
        \PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regridSrc2Dst}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{srcfracfield}\PYG{p}{,} \PYG{n}{dstfracfield}
\end{sphinxVerbatim}
\end{quote}


\subsection{Compute Field Mass}
\label{\detokenize{examples:compute-field-mass}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{compute\PYGZus{}mass\PYGZus{}grid}\PYG{p}{(}\PYG{n}{valuefield}\PYG{p}{,} \PYG{n}{dofrac}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{fracfield}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
                      \PYG{n}{uninitval}\PYG{o}{=}\PYG{l+m+mf}{422397696.}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    PRECONDITIONS: \PYGZsq{}fracfield\PYGZsq{} contains the fractions of each cell}
\PYG{l+s+sd}{                   which contributed to a regridding operation involving}
\PYG{l+s+sd}{                   \PYGZsq{}valuefield.  \PYGZsq{}dofrac\PYGZsq{} is a boolean value that gives }
\PYG{l+s+sd}{                   the option to not use the \PYGZsq{}fracfield\PYGZsq{}.\PYGZbs{}n}
\PYG{l+s+sd}{    POSTCONDITIONS: The mass of the data field is computed.\PYGZbs{}n}
\PYG{l+s+sd}{    RETURN VALUES: float :: mass \PYGZbs{}n}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{mass} \PYG{o}{=} \PYG{l+m+mf}{0.0}
    \PYG{n}{areafield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{valuefield}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{areafield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{areafield}\PYG{o}{.}\PYG{n}{get\PYGZus{}area}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{ind} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{valuefield}\PYG{o}{.}\PYG{n}{data} \PYG{o}{!=} \PYG{n}{uninitval}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{dofrac}\PYG{p}{:}
        \PYG{n}{mass} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{areafield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{*} \PYG{n}{valuefield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{*} \PYG{n}{fracfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{mass} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{areafield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{*} \PYG{n}{valuefield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{mass}
\end{sphinxVerbatim}
\end{quote}


\section{Regridding}
\label{\detokenize{examples:regridding}}
The following stand alone scripts demonstrate how to use regridding between
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} built on
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grids}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}}
and {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStreams}}}}}. These scripts
can be run in serial or parallel with no modification.


\subsection{Grid, Mesh and Field Created from File}
\label{\detokenize{examples:grid-mesh-and-field-created-from-file}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This example demonstrates how to create ESMPy Grid, Mesh and Field objects }
\PYG{c+c1}{\PYGZsh{} from file and use them for regridding.}
\PYG{c+c1}{\PYGZsh{} The data files can be retrieved from the ESMF data repository by uncommenting the}
\PYG{c+c1}{\PYGZsh{} following block of code:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} import os}
\PYG{c+c1}{\PYGZsh{} DD = os.path.join(os.getcwd(), \PYGZdq{}examples/data\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} if not os.path.isdir(DD):}
\PYG{c+c1}{\PYGZsh{}     os.makedirs(DD)}
\PYG{c+c1}{\PYGZsh{} from ESMF.util.cache\PYGZus{}data import cache\PYGZus{}data\PYGZus{}file}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}so\PYGZus{}Omon\PYGZus{}GISS\PYGZhy{}E2.nc\PYGZdq{}))}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}mpas\PYGZus{}uniform\PYGZus{}10242\PYGZus{}dual\PYGZus{}counterclockwise.nc\PYGZdq{}))}

\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}

\PYG{c+c1}{\PYGZsh{} This call enables debug logging}
\PYG{c+c1}{\PYGZsh{} ESMF.Manager(debug=True)}

\PYG{c+c1}{\PYGZsh{} Set up the DATADIR}
\PYG{n}{DATADIR} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{examples/data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a  global grid from a GRIDSPEC formatted file}
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DATADIR}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{so\PYGZus{}Omon\PYGZus{}GISS\PYGZhy{}E2.nc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                 \PYG{n}{filetype}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{FileFormat}\PYG{o}{.}\PYG{n}{GRIDSPEC}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a field on the centers of the grid, with extra dimensions}
\PYG{n}{srcfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,} \PYG{n}{ndbounds}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{33}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Read the field data from file}
\PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DATADIR}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{so\PYGZus{}Omon\PYGZus{}GISS\PYGZhy{}E2.nc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
           \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{so}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeslice}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create an ESMF formatted unstructured mesh with clockwise cells removed}
\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DATADIR}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mpas\PYGZus{}uniform\PYGZus{}10242\PYGZus{}dual\PYGZus{}counterclockwise.nc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                 \PYG{n}{filetype}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{FileFormat}\PYG{o}{.}\PYG{n}{ESMFMESH}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a field on the nodes of the mesh}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{meshloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshLoc}\PYG{o}{.}\PYG{n}{NODE}\PYG{p}{,} \PYG{n}{ndbounds}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{33}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e20}

\PYG{c+c1}{\PYGZsh{} compute the weight matrix for regridding}
\PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,}
                     \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{BILINEAR}\PYG{p}{,}
                     \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{IGNORE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} calculate the regridding from source to destination field}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fields created from file regridded successfully :)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\subsection{Read and Write a Weight File}
\label{\detokenize{examples:read-and-write-a-weight-file}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This example demonstrates how to regrid between a Grid and a Mesh.}
\PYG{c+c1}{\PYGZsh{} The data files can be retrieved from the ESMF data repository by uncommenting the}
\PYG{c+c1}{\PYGZsh{} following block of code:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} import os}
\PYG{c+c1}{\PYGZsh{} DD = os.path.join(os.getcwd(), \PYGZdq{}examples/data\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} if not os.path.isdir(DD):}
\PYG{c+c1}{\PYGZsh{}     os.makedirs(DD)}
\PYG{c+c1}{\PYGZsh{} from ESMF.util.cache\PYGZus{}data import cache\PYGZus{}data\PYGZus{}file}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}ll2.5deg\PYGZus{}grid.nc\PYGZdq{}))}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}mpas\PYGZus{}uniform\PYGZus{}10242\PYGZus{}dual\PYGZus{}counterclockwise.nc\PYGZdq{}))}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{helpers} \PYG{k}{as} \PYG{n+nn}{helpers}
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{api}\PYG{n+nn}{.}\PYG{n+nn}{constants} \PYG{k}{as} \PYG{n+nn}{constants}

\PYG{c+c1}{\PYGZsh{} This call enables debug logging}
\PYG{n}{mg} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} ESMPy uses Fortran style dimension ordering (as of November 2017)}
\PYG{p}{[}\PYG{n}{lat}\PYG{p}{,}\PYG{n}{lon}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Create the source grid from memory with periodic dimension specified.}
\PYG{n}{lons} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{350.1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{lats}  \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mf}{85.1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{srcgrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lons}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{n}{lats}\PYG{o}{.}\PYG{n}{size}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,}
                    \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,}
                    \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pole\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Get and set the source grid coordinates.}
\PYG{n}{srcGridCoordLon} \PYG{o}{=} \PYG{n}{srcgrid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{)}
\PYG{n}{srcGridCoordLat} \PYG{o}{=} \PYG{n}{srcgrid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}

\PYG{n}{slons\PYGZus{}par} \PYG{o}{=} \PYG{n}{lons}\PYG{p}{[}\PYG{n}{srcgrid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}\PYG{n}{srcgrid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{slats\PYGZus{}par} \PYG{o}{=} \PYG{n}{lats}\PYG{p}{[}\PYG{n}{srcgrid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}\PYG{n}{srcgrid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} make sure to use indexing=\PYGZsq{}ij\PYGZsq{} as ESMPy backend uses matrix indexing (not Cartesian)}
\PYG{n}{lonm}\PYG{p}{,} \PYG{n}{latm} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{slons\PYGZus{}par}\PYG{p}{,} \PYG{n}{slats\PYGZus{}par}\PYG{p}{,} \PYG{n}{indexing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ij}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{srcGridCoordLon}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lonm}
\PYG{n}{srcGridCoordLat}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{latm}

\PYG{c+c1}{\PYGZsh{} Create the dest grid from memory with periodic dimension specified.}
\PYG{n}{lons} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{357.6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{lats} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{87.5}\PYG{p}{,} \PYG{l+m+mf}{87.6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{dstgrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lons}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{n}{lats}\PYG{o}{.}\PYG{n}{size}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,}
                    \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,}
                    \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{pole\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Get and set the source grid coordinates.}
\PYG{n}{dstGridCoordLat} \PYG{o}{=} \PYG{n}{dstgrid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}
\PYG{n}{dstGridCoordLon} \PYG{o}{=} \PYG{n}{dstgrid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{)}

\PYG{n}{dlons\PYGZus{}par} \PYG{o}{=} \PYG{n}{lons}\PYG{p}{[}\PYG{n}{dstgrid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}\PYG{n}{dstgrid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{dlats\PYGZus{}par} \PYG{o}{=} \PYG{n}{lats}\PYG{p}{[}\PYG{n}{dstgrid}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}\PYG{n}{dstgrid}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} make sure to use indexing=\PYGZsq{}ij\PYGZsq{} as ESMPy backend uses matrix indexing (not Cartesian)}
\PYG{n}{lonm}\PYG{p}{,} \PYG{n}{latm} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{dlons\PYGZus{}par}\PYG{p}{,} \PYG{n}{dlats\PYGZus{}par}\PYG{p}{,} \PYG{n}{indexing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ij}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{dstGridCoordLon}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lonm}
\PYG{n}{dstGridCoordLat}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{latm}

\PYG{c+c1}{\PYGZsh{} Create a field on the centers of the source grid with the mask applied.}
\PYG{n}{srcfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{srcgrid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{srcfield}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a field on the centers of the source grid with the mask applied.}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{dstgrid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dstfield}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
\PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{dstgrid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xctfield}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}

\PYG{n}{gridLon} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
\PYG{n}{gridLat} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} wave = lambda x,k:  numpy.sin(x*k*numpy.pi/180.0)}
\PYG{c+c1}{\PYGZsh{} srcfield.data[...] = numpy.outer(wave(slons\PYGZus{}par,3), wave(slats\PYGZus{}par,3)) + 2}

\PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{srcGridCoordLat}\PYG{p}{)}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYGZbs{}
                           \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{srcGridCoordLon}\PYG{p}{)}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} wave = lambda x,k:  numpy.sin(x*k*numpy.pi/180.0)}
\PYG{c+c1}{\PYGZsh{} xctfield.data[...] = numpy.outer(wave(dlons\PYGZus{}par,3), wave(dlats\PYGZus{}par,3)) + 2}

\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{dstGridCoordLat}\PYG{p}{)}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYGZbs{}
                           \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{dstGridCoordLon}\PYG{p}{)}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e20}

\PYG{c+c1}{\PYGZsh{} write regridding weights to file}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{esmpy\PYGZus{}example\PYGZus{}weight\PYGZus{}file.nc}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{os}
    \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{mg}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{filename}\PYG{o}{=}\PYG{n}{filename}\PYG{p}{,}
                     \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{BILINEAR}\PYG{p}{,}
                     \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{IGNORE}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} \PYGZsh{} create a regrid object from file}
\PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridFromFile}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} calculate the regridding from source to destination field}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compute the mean relative error}
\PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{relerr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{meanrelerr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{if} \PYG{n}{num\PYGZus{}nodes} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data} \PYG{o}{\PYGZhy{}} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{/}
                       \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}

\PYG{c+c1}{\PYGZsh{} handle the parallel case}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{relerr}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}
    \PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{num\PYGZus{}nodes}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} output the results from one processor only}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMPy Grid Mesh Regridding Example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  interpolation mean relative error = }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{meanrelerr}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set to 1 to output results}
\PYG{c+c1}{\PYGZsh{} if ESMF.pet\PYGZus{}count() == 0:}
\PYG{c+c1}{\PYGZsh{}     import matplotlib.pyplot as plt}
\PYG{c+c1}{\PYGZsh{}     fig = plt.figure(1, (15, 6))}
\PYG{c+c1}{\PYGZsh{}     fig.suptitle(\PYGZsq{}ESMPy Periodic Grids\PYGZsq{}, fontsize=14, fontweight=\PYGZsq{}bold\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     ax = fig.add\PYGZus{}subplot(1, 2, 1)}
\PYG{c+c1}{\PYGZsh{}     im = ax.imshow(srcfield.data, vmin=1, vmax=3, cmap=\PYGZsq{}gist\PYGZus{}ncar\PYGZsq{}, aspect=\PYGZsq{}auto\PYGZsq{},}
\PYG{c+c1}{\PYGZsh{}                    extent=[min(slons\PYGZus{}par), max(slons\PYGZus{}par), min(slats\PYGZus{}par), max(slats\PYGZus{}par)])}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}xbound(lower=min(slons\PYGZus{}par), upper=max(slons\PYGZus{}par))}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}ybound(lower=min(slats\PYGZus{}par), upper=max(slats\PYGZus{}par))}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}xlabel(\PYGZdq{}Longitude\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}ylabel(\PYGZdq{}Latitude\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}title(\PYGZdq{}Source Data\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     ax = fig.add\PYGZus{}subplot(1, 2, 2)}
\PYG{c+c1}{\PYGZsh{}     im = ax.imshow(dstfield.data, vmin=1, vmax=3, cmap=\PYGZsq{}gist\PYGZus{}ncar\PYGZsq{}, aspect=\PYGZsq{}auto\PYGZsq{},}
\PYG{c+c1}{\PYGZsh{}                    extent=[min(dlons\PYGZus{}par), max(dlons\PYGZus{}par), min(dlats\PYGZus{}par), max(dlats\PYGZus{}par)])}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}xlabel(\PYGZdq{}Longitude\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}ylabel(\PYGZdq{}Latitude\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{}     ax.set\PYGZus{}title(\PYGZdq{}Regrid Solution\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     fig.subplots\PYGZus{}adjust(right=0.8)}
\PYG{c+c1}{\PYGZsh{}     cbar\PYGZus{}ax = fig.add\PYGZus{}axes([0.9, 0.1, 0.01, 0.8])}
\PYG{c+c1}{\PYGZsh{}     fig.colorbar(im, cax=cbar\PYGZus{}ax)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     plt.show()}
\end{sphinxVerbatim}
\end{quote}


\subsection{Grid to LocStream}
\label{\detokenize{examples:grid-to-locstream}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This example demonstrates how to regrid between a Grid and a LocStream.}
\PYG{c+c1}{\PYGZsh{} The data files can be retrieved from the ESMF data repository by uncommenting the}
\PYG{c+c1}{\PYGZsh{} following block of code:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} import os}
\PYG{c+c1}{\PYGZsh{} DD = os.path.join(os.getcwd(), \PYGZdq{}examples/data\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} if not os.path.isdir(DD):}
\PYG{c+c1}{\PYGZsh{}     os.makedirs(DD)}
\PYG{c+c1}{\PYGZsh{} from ESMF.util.cache\PYGZus{}data import cache\PYGZus{}data\PYGZus{}file}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}ll1deg\PYGZus{}grid.nc\PYGZdq{}))}

\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{unittest} \PYG{k}{import} \PYG{n}{SkipTest}
\PYG{k}{except} \PYG{n+ne}{ImportError}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{nose} \PYG{k}{import} \PYG{n}{SkipTest}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{helpers} \PYG{k}{as} \PYG{n+nn}{helpers}
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{api}\PYG{n+nn}{.}\PYG{n+nn}{constants} \PYG{k}{as} \PYG{n+nn}{constants}

\PYG{c+c1}{\PYGZsh{} This call enables debug logging}
\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{locstream\PYGZus{}utilities} \PYG{k}{import} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16}\PYG{p}{,} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16\PYGZus{}parallel}
\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}
\PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16}\PYG{p}{(}\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{n}{domask}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{\PYGZus{}ESMF\PYGZus{}MPIRUN\PYGZus{}NP} \PYG{o}{!=} \PYG{l+m+mi}{4}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n}{SkipTest}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{processor count must be 4 or 1 for this example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16\PYGZus{}parallel}\PYG{p}{(}\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{n}{domask}\PYG{p}{)}

\PYG{n}{grid1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{examples/data/ll1deg\PYGZus{}grid.nc}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{grid1}\PYG{p}{,} \PYG{n}{filetype}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{FileFormat}\PYG{o}{.}\PYG{n}{SCRIP}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a field}
\PYG{n}{srcfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{srcfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{locstream}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dstfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{locstream}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xctfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} initialize the fields}
\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{deg2rad} \PYG{o}{=} \PYG{l+m+mf}{3.14159}\PYG{o}{/}\PYG{l+m+mi}{180}

\PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)}

\PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{if} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{:}
    \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}RAD}\PYG{p}{:}
    \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{gridXCoord}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{gridYCoord}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coordsys value does not work in this example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e20}

\PYG{c+c1}{\PYGZsh{} create an object to regrid data from the source to the destination field}
\PYG{n}{dst\PYGZus{}mask\PYGZus{}values}\PYG{o}{=}\PYG{k+kc}{None}
\PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
    \PYG{n}{dst\PYGZus{}mask\PYGZus{}values}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,}
                     \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{BILINEAR}\PYG{p}{,}
                     \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{ERROR}\PYG{p}{,}
                     \PYG{n}{dst\PYGZus{}mask\PYGZus{}values}\PYG{o}{=}\PYG{n}{dst\PYGZus{}mask\PYGZus{}values}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} do the regridding from source to destination field}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{zero\PYGZus{}region}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Region}\PYG{o}{.}\PYG{n}{SELECT}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compute the mean relative error}
\PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{relerr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{meanrelerr} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ravel}\PYG{p}{(}\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ravel}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{num\PYGZus{}nodes} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{ind} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{n}{dstfield} \PYG{o}{!=} \PYG{l+m+mf}{1e20}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{xctfield} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{dstfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}

\PYG{c+c1}{\PYGZsh{} handle the parallel case}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{relerr}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}
    \PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{num\PYGZus{}nodes}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} output the results from one processor only}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMPy Grid LocStream Regridding Example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  interpolation mean relative error = }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{meanrelerr}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{assert} \PYG{p}{(}\PYG{n}{meanrelerr} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2e\PYGZhy{}2}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\subsection{Mesh to LocStream}
\label{\detokenize{examples:mesh-to-locstream}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This example demonstrates how to regrid between a mesh and a locstream.}

\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{unittest} \PYG{k}{import} \PYG{n}{SkipTest}
\PYG{k}{except} \PYG{n+ne}{ImportError}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{nose} \PYG{k}{import} \PYG{n}{SkipTest}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{helpers} \PYG{k}{as} \PYG{n+nn}{helpers}
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{api}\PYG{n+nn}{.}\PYG{n+nn}{constants} \PYG{k}{as} \PYG{n+nn}{constants}

\PYG{c+c1}{\PYGZsh{} This call enables debug logging}
\PYG{c+c1}{\PYGZsh{} ESMF.Manager(debug=True)}

\PYG{k+kn}{from} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{mesh\PYGZus{}utilities} \PYG{k}{import} \PYG{n}{mesh\PYGZus{}create\PYGZus{}5}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}create\PYGZus{}5\PYGZus{}parallel}
\PYG{k+kn}{from} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{locstream\PYGZus{}utilities} \PYG{k}{import} \PYG{n}{create\PYGZus{}locstream\PYGZus{}16}\PYG{p}{,} \PYG{n}{create\PYGZus{}locstream\PYGZus{}16\PYGZus{}parallel}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{mesh}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{mesh\PYGZus{}create\PYGZus{}5}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{create\PYGZus{}locstream\PYGZus{}16}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{\PYGZus{}ESMF\PYGZus{}MPIRUN\PYGZus{}NP} \PYG{o}{!=} \PYG{l+m+mi}{4}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n}{SkipTest}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{processor count must be 4 or 1 for this example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{mesh}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{mesh\PYGZus{}create\PYGZus{}5\PYGZus{}parallel}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{create\PYGZus{}locstream\PYGZus{}16\PYGZus{}parallel}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a field}
\PYG{n}{srcfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{srcfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{}, meshloc=ESMF.MeshLoc.ELEMENT)}

\PYG{c+c1}{\PYGZsh{} create a field on the locstream}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{locstream}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dstfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{locstream}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xctfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} initialize the fields}
\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{deg2rad} \PYG{o}{=} \PYG{l+m+mf}{3.14159}\PYG{o}{/}\PYG{l+m+mi}{180}

\PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e20}

\PYG{c+c1}{\PYGZsh{} create an object to regrid data from the source to the destination field}
\PYG{c+c1}{\PYGZsh{} TODO: this example seems to fail occasionally with UnmappedAction.ERROR, probably due to a tolerance issue \PYGZhy{} ask Bob}
\PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{o}{=}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{o}{=}\PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{BILINEAR}\PYG{p}{,}
                     \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{IGNORE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} do the regridding from source to destination field}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compute the mean relative error}
\PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{relerr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{meanrelerr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{if} \PYG{n}{num\PYGZus{}nodes} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{ind} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data} \PYG{o}{!=} \PYG{l+m+mf}{1e20}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}

\PYG{c+c1}{\PYGZsh{} handle the parallel case}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{relerr}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}
    \PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{num\PYGZus{}nodes}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} output the results from one processor only}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMPy Grid Mesh Regridding Example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  interpolation mean relative error = }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{meanrelerr}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{assert} \PYG{p}{(}\PYG{n}{meanrelerr} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{3e\PYGZhy{}5}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\subsection{LocStream to Grid}
\label{\detokenize{examples:locstream-to-grid}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This example demonstrates how to regrid between a LocStream and a Grid.}
\PYG{c+c1}{\PYGZsh{} The data files can be retrieved from the ESMF data repository by uncommenting the}
\PYG{c+c1}{\PYGZsh{} following block of code:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} import os}
\PYG{c+c1}{\PYGZsh{} DD = os.path.join(os.getcwd(), \PYGZdq{}examples/data\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} if not os.path.isdir(DD):}
\PYG{c+c1}{\PYGZsh{}     os.makedirs(DD)}
\PYG{c+c1}{\PYGZsh{} from ESMF.util.cache\PYGZus{}data import cache\PYGZus{}data\PYGZus{}file}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}ll1deg\PYGZus{}grid.nc\PYGZdq{}))}

\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{unittest} \PYG{k}{import} \PYG{n}{SkipTest}
\PYG{k}{except} \PYG{n+ne}{ImportError}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{nose} \PYG{k}{import} \PYG{n}{SkipTest}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}

\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{helpers} \PYG{k}{as} \PYG{n+nn}{helpers}
\PYG{k+kn}{import} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{api}\PYG{n+nn}{.}\PYG{n+nn}{constants} \PYG{k}{as} \PYG{n+nn}{constants}

\PYG{c+c1}{\PYGZsh{} This call enables debug logging}
\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{grid1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{examples/data/ll1deg\PYGZus{}grid.nc}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{grid1}\PYG{p}{,} \PYG{n}{filetype}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{FileFormat}\PYG{o}{.}\PYG{n}{SCRIP}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{ESMF}\PYG{n+nn}{.}\PYG{n+nn}{util}\PYG{n+nn}{.}\PYG{n+nn}{locstream\PYGZus{}utilities} \PYG{k}{import} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16}\PYG{p}{,} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16\PYGZus{}parallel}
\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}
\PYG{n}{domask}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16}\PYG{p}{(}\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{n}{domask}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{\PYGZus{}ESMF\PYGZus{}MPIRUN\PYGZus{}NP} \PYG{o}{!=} \PYG{l+m+mi}{4}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n}{SkipTest}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{processor count must be 4 or 1 for this example}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{locstream} \PYG{o}{=} \PYG{n}{create\PYGZus{}locstream\PYGZus{}spherical\PYGZus{}16\PYGZus{}parallel}\PYG{p}{(}\PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{,} \PYG{n}{domask}\PYG{o}{=}\PYG{n}{domask}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a field}
\PYG{n}{srcfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{locstream}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{srcfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dstfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xctfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} initialize the fields}
\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{deg2rad} \PYG{o}{=} \PYG{l+m+mf}{3.14159}\PYG{o}{/}\PYG{l+m+mi}{180}

\PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{if} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{:}
    \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}RAD}\PYG{p}{:}
    \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{gridXCoord}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{gridYCoord}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coordsys value does not apply in this example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)}


\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e20}

\PYG{c+c1}{\PYGZsh{} create an object to regrid data from the source to the destination field}
\PYG{n}{mask\PYGZus{}values}\PYG{o}{=}\PYG{k+kc}{None}
\PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
    \PYG{n}{mask\PYGZus{}values}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,}
                     \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{NEAREST\PYGZus{}DTOS}\PYG{p}{,}
                     \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{ERROR}\PYG{p}{,}
                     \PYG{n}{src\PYGZus{}mask\PYGZus{}values}\PYG{o}{=}\PYG{n}{mask\PYGZus{}values}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} do the regridding from source to destination field}
\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{zero\PYGZus{}region}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Region}\PYG{o}{.}\PYG{n}{SELECT}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compute the mean relative error}
\PYG{k+kn}{from} \PYG{n+nn}{operator} \PYG{k}{import} \PYG{n}{mul}
\PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{relerr} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{meanrelerr} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ravel}\PYG{p}{(}\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ravel}\PYG{p}{(}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{num\PYGZus{}nodes} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{ind} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{n}{dstfield} \PYG{o}{!=} \PYG{l+m+mf}{1e20}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{xctfield} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{dstfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}

\PYG{c+c1}{\PYGZsh{} handle the parallel case}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{relerr}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}
    \PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{helpers}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}val}\PYG{p}{(}\PYG{n}{num\PYGZus{}nodes}\PYG{p}{,} \PYG{n}{op}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{Reduce}\PYG{o}{.}\PYG{n}{SUM}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} output the results from one processor only}
\PYG{k}{if} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMPy LocStream Grid Regridding Example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  interpolation mean relative error = }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{meanrelerr}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{assert} \PYG{p}{(}\PYG{n}{meanrelerr} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{9e\PYGZhy{}5}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\subsection{Using MPI.Spawn() from a Serial Python Driver}
\label{\detokenize{examples:using-mpi-spawn-from-a-serial-python-driver}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This example demonstrates how to call ESMPy regridding as a parallel}
\PYG{c+c1}{\PYGZsh{} subprocess spawned using mpi4py from a serial Python driver.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} NOTE: MPI.COMM\PYGZus{}WORLD.Spawn does not seem to work for mpi4py installations}
\PYG{c+c1}{\PYGZsh{}       installations built with mpich, however openmpi does work (July 2016).}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} The data files can be retrieved from the ESMF data repository by uncommenting the}
\PYG{c+c1}{\PYGZsh{} following block of code:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} import os}
\PYG{c+c1}{\PYGZsh{} DD = os.path.join(os.getcwd(), \PYGZdq{}examples/data\PYGZdq{})}
\PYG{c+c1}{\PYGZsh{} if not os.path.isdir(DD):}
\PYG{c+c1}{\PYGZsh{}     os.makedirs(DD)}
\PYG{c+c1}{\PYGZsh{} from ESMF.util.cache\PYGZus{}data import cache\PYGZus{}data\PYGZus{}file}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}ll1deg\PYGZus{}grid.nc\PYGZdq{}))}
\PYG{c+c1}{\PYGZsh{} cache\PYGZus{}data\PYGZus{}file(os.path.join(DD, \PYGZdq{}mpas\PYGZus{}uniform\PYGZus{}10242\PYGZus{}dual\PYGZus{}counterclockwise.nc\PYGZdq{}))}

\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{from} \PYG{n+nn}{mpi4py} \PYG{k}{import} \PYG{n}{MPI}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{k}{def} \PYG{n+nf}{regrid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k+kn}{import} \PYG{n+nn}{ESMF}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ImportError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF is not available on this machine}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{grid1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{examples/data/ll1deg\PYGZus{}grid.nc}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{grid2} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{examples/data/mpas\PYGZus{}uniform\PYGZus{}10242\PYGZus{}dual\PYGZus{}counterclockwise.nc}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{c+c1}{\PYGZsh{} Create a uniform global latlon grid from a SCRIP formatted file}
    \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{grid1}\PYG{p}{,} \PYG{n}{filetype}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{FileFormat}\PYG{o}{.}\PYG{n}{SCRIP}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} NOTE: corners are needed for conservative regridding}
    \PYG{c+c1}{\PYGZsh{} grid = ESMF.Grid(filename=grid1, filetype=ESMF.FileFormat.SCRIP,}
    \PYG{c+c1}{\PYGZsh{}                  add\PYGZus{}corner\PYGZus{}stagger=True)}

    \PYG{c+c1}{\PYGZsh{} create a field on the center stagger locations of the source grid}
    \PYG{n}{srcfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{srcfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                          \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create an ESMF formatted unstructured mesh with clockwise cells removed}
    \PYG{n}{mesh} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{grid2}\PYG{p}{,} \PYG{n}{filetype}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{FileFormat}\PYG{o}{.}\PYG{n}{ESMFMESH}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create a field on the nodes of the destination mesh}
    \PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dstfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{meshloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshLoc}\PYG{o}{.}\PYG{n}{NODE}\PYG{p}{)}
    \PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xctfield}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{meshloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshLoc}\PYG{o}{.}\PYG{n}{NODE}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} NOTE: Field must be built on elements of Mesh for conservative regridding}
    \PYG{c+c1}{\PYGZsh{} dstfield = ESMF.Field(mesh, name=\PYGZsq{}dstfield\PYGZsq{}, meshloc=ESMF.MeshLoc.ELEMENT)}
    \PYG{c+c1}{\PYGZsh{} xctfield = ESMF.Field(mesh, name=\PYGZsq{}xctfield\PYGZsq{}, meshloc=ESMF.MeshLoc.ELEMENT)}

    \PYG{c+c1}{\PYGZsh{} initialize the fields}
    \PYG{p}{[}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{deg2rad} \PYG{o}{=} \PYG{l+m+mf}{3.14159} \PYG{o}{/} \PYG{l+m+mi}{180}

    \PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
    \PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
    \PYG{n}{srcfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}
                                                              \PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

    \PYG{n}{gridXCoord} \PYG{o}{=} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
    \PYG{n}{gridYCoord} \PYG{o}{=} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
    \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.0} \PYG{o}{+} \PYG{p}{(}\PYG{n}{gridXCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}
                                                              \PYG{n}{gridYCoord} \PYG{o}{*} \PYG{n}{deg2rad}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

    \PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e20}

    \PYG{c+c1}{\PYGZsh{} create an object to regrid data from the source to the destination field}
    \PYG{n}{regrid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{,}
                         \PYG{n}{regrid\PYGZus{}method}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{RegridMethod}\PYG{o}{.}\PYG{n}{BILINEAR}\PYG{p}{,}
                         \PYG{n}{unmapped\PYGZus{}action}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{UnmappedAction}\PYG{o}{.}\PYG{n}{ERROR}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} do the regridding from source to destination field}
    \PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{srcfield}\PYG{p}{,} \PYG{n}{dstfield}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{xctfield}

\PYG{k}{def} \PYG{n+nf}{compute\PYGZus{}error}\PYG{p}{(}\PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{xctfield}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} compute the mean relative error}
    \PYG{k+kn}{from} \PYG{n+nn}{operator} \PYG{k}{import} \PYG{n}{mul}
    \PYG{n}{num\PYGZus{}nodes} \PYG{o}{=} \PYG{n}{reduce}\PYG{p}{(}\PYG{n}{mul}\PYG{p}{,} \PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
    \PYG{n}{relerr} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{num\PYGZus{}nodes} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{ind} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{p}{(}\PYG{n}{dstfield} \PYG{o}{!=} \PYG{l+m+mf}{1e20}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{xctfield} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{relerr} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}
            \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{dstfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}
                \PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}

    \PYG{n}{meanrelerr} \PYG{o}{=} \PYG{n}{relerr} \PYG{o}{/} \PYG{n}{num\PYGZus{}nodes}
    \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMPy regridding as a spawned MPI process:}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  interpolation mean relative error = }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{meanrelerr}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} MAIN \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{n}{start\PYGZus{}worker} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{worker}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{usage} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Program should be started without arguments}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{pet\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{4}

\PYG{c+c1}{\PYGZsh{} Parent}
\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Spawn workers}
    \PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}\PYG{o}{.}\PYG{n}{Spawn}\PYG{p}{(}
        \PYG{n}{sys}\PYG{o}{.}\PYG{n}{executable}\PYG{p}{,}
        \PYG{n}{args}\PYG{o}{=}\PYG{p}{[}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start\PYGZus{}worker}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{maxprocs}\PYG{o}{=}\PYG{n}{pet\PYGZus{}count}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} gather output fields from workers}
    \PYG{n}{dstfield} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{comm}\PYG{o}{.}\PYG{n}{gather}\PYG{p}{(}\PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{root}\PYG{o}{=}\PYG{n}{MPI}\PYG{o}{.}\PYG{n}{ROOT}\PYG{p}{)}
    \PYG{n}{dstfield} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{[}\PYG{n}{dstfield}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{pet\PYGZus{}count}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{xctfield} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{comm}\PYG{o}{.}\PYG{n}{gather}\PYG{p}{(}\PYG{n}{xctfield}\PYG{p}{,} \PYG{n}{root}\PYG{o}{=}\PYG{n}{MPI}\PYG{o}{.}\PYG{n}{ROOT}\PYG{p}{)}
    \PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xctfield}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{pet\PYGZus{}count}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} plot results}
    \PYG{n}{compute\PYGZus{}error}\PYG{p}{(}\PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{xctfield}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Shutdown}
    \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Disconnect}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Worker}
\PYG{k}{elif} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{n}{start\PYGZus{}worker}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Connect to parent}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{Comm}\PYG{o}{.}\PYG{n}{Get\PYGZus{}parent}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{rank} \PYG{o}{=} \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Get\PYGZus{}rank}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Could not connect to parent \PYGZhy{} }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{usage}\PYG{p}{)}

    \PYG{k}{try}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} call ESMPy regridding}
        \PYG{n}{dstfield}\PYG{p}{,} \PYG{n}{xctfield} \PYG{o}{=} \PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} send output to parent}
        \PYG{n}{comm}\PYG{o}{.}\PYG{n}{gather}\PYG{p}{(}\PYG{n}{sendobj}\PYG{o}{=}\PYG{n}{dstfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{root}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{comm}\PYG{o}{.}\PYG{n}{gather}\PYG{p}{(}\PYG{n}{sendobj}\PYG{o}{=}\PYG{n}{xctfield}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{root}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Disconnect}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Shutdown}
    \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Disconnect}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Catch}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{n}{usage}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\chapter{API}
\label{\detokenize{api:api}}\label{\detokenize{api::doc}}

\section{Classes}
\label{\detokenize{api:classes}}
ESMPy uses a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} object to represent data variables
built on an underlying spatial discretization, which is represented by a
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.
Regridding between {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} is accomplished with the
{\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} class.  All of these classes are explained in
more detail in the sections provided by the links in the following table.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Class
&\sphinxstyletheadfamily 
Description
\\
\hline
{\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}}
&
A manager class to initialize and finalize ESMF
\\
\hline
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
&
A data field built on a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}
\\
\hline
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
&
A class to represent a logically rectangular grid
\\
\hline
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
&
A class to represent an unstructured grid
\\
\hline
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}
&
A class to represent observational data as a collection of disconnected points
\\
\hline
{\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}
&
The regridding utility
\\
\hline
{\hyperref[\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridFromFile}}}}}
&
The from file regridding utility
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Named Constants}
\label{\detokenize{api:named-constants}}
ESMPy follows the ESMF convention of using “named constants” to represent the
available options for parameters that expect a variety of specific inputs.  The
following table lists the available named constants and provides links to pages
that further explain the available values.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Named constants
&\sphinxstyletheadfamily 
Description
\\
\hline
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CoordSys}}}}}
&
Specify the coordinate system of a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
\\
\hline
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FileFormat}}}}}
&
Specify the format of a data file
\\
\hline
{\hyperref[\detokenize{FileMode:ESMF.api.constants.FileMode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FileMode}}}}}
&
Specify the mode of a data file
\\
\hline
{\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GridItem}}}}}
&
Specify a mask or area item on a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
\\
\hline
{\hyperref[\detokenize{LineType:ESMF.api.constants.LineType}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LineType}}}}}
&
Specify the type of line that connects two points on a sphere
\\
\hline
{\hyperref[\detokenize{LogKind:ESMF.api.constants.LogKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LogKind}}}}}
&
Specify how much logging should be done
\\
\hline
{\hyperref[\detokenize{MeshElemType:ESMF.api.constants.MeshElemType}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshElemType}}}}}
&
Specify the type of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} elements
\\
\hline
{\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshLoc}}}}}
&
Specify a nodal or elemental {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
\\
\hline
{\hyperref[\detokenize{NormType:ESMF.api.constants.NormType}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NormType}}}}}
&
Specify the type of normalization to use for conservative regridding weights
\\
\hline
{\hyperref[\detokenize{PoleKind:ESMF.api.constants.PoleKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PoleKind}}}}}
&
Specify the type of connection that appears at the poles of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
\\
\hline
{\hyperref[\detokenize{PoleMethod:ESMF.api.constants.PoleMethod}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PoleMethod}}}}}
&
Specify which type of artificial pole to construct on the source {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} for regridding
\\
\hline
{\hyperref[\detokenize{Region:ESMF.api.constants.Region}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Region}}}}}
&
Specify various regions in the data layout of
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridMethod}}}}}
&
Specify which interpolation method to use regridding
\\
\hline
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StaggerLoc}}}}}
&
Specify the position for data in a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell
\\
\hline
{\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TypeKind}}}}}
&
Specify the type and kind of data
\\
\hline
{\hyperref[\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UnmappedAction}}}}}
&
Specify which action to take with respect to unmapped destination points
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Manager}
\label{\detokenize{api:manager}}
The {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} is used by ESMPy to simplify a
number of low-level calls used by the underlying ESMF framework to allocate
resources, enable logging, and control garbage collection.


\subsection{Resource Allocation}
\label{\detokenize{api:resource-allocation}}
The ESMF Virtual Machine (VM) \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node6.html\#SECTION060120000000000000000}{ESMF Virtual Machine (VM)}
is created at the beginning of each ESMPy execution, and contains information
about the topology and characteristics of the underlying computer. The VM
allocates computational resources in the form of
\sphinxstylestrong{Persistent Execution Threads}, or \sphinxstylestrong{PETs}. These are equivalent to operating
system threads with a lifetime of at least that of the ESMPy execution. In the
simplest, and most common case, a PET is equivalent to an MPI process. The
number of PETs and the current PET can be queried from the
{\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mg} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pet\PYGZus{}count} \PYG{o}{=} \PYG{n}{mg}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{local\PYGZus{}pet} \PYG{o}{=} \PYG{n}{mg}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Logging}
\label{\detokenize{api:logging}}
The {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} is also used to enable logging:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mg} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{n}{debug}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{local\PYGZus{}pet} \PYG{o}{=} \PYG{n}{mg}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

The output will be logged in files named PET\textless{}local\_pet\textgreater{}.ESMF\_LogFile.


\subsection{Garbage Collection}
\label{\detokenize{api:garbage-collection}}
The underlying ESMF framework needs to be initialized and finalized once and
only once per execution. This is handled internally by the
{\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} and \sphinxstylestrong{does not} require any explicit
user intervention. However, the ESMF garbage collection feature is not triggered
until the finalization routine is invoked. So if memory deallocation of ESMPy
objects is required \sphinxstyleemphasis{prior} to the end of the program, the class level
\sphinxcode{\sphinxupquote{destroy}} routines should be invoked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mg} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{mg}\PYG{o}{.}\PYG{n}{destroy}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

This is commonly required when reusing a {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} object
to interpolate data between many {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} pairs to
conserve memory to complete all interpolations in a single execution.


\section{Spatial Discretization Objects}
\label{\detokenize{api:spatial-discretization-objects}}
There are three different objects used for spatial coordinate representation:
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, and {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}. {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grids}}}}} are used to represent logically rectangular
grids, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}} are used for unstructured collections of polygons, and
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStreams}}}}} are used for unstructured collections of individual points. These
objects are nearly identical counterparts to the objects of the same name in
ESMF, with some simplifications for ease of use in the Python environment.


\subsection{Grid}
\label{\detokenize{api:grid}}
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} is used to represent the geometry and discretization of logically
rectangular physical grids. The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} can also hold information that can used in
calculations involving the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, like a mask or the cell areas. The ESMF reference
manual has an in-depth description of the
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05080000000000000000}{Grid class}.


\subsubsection{Staggering}
\label{\detokenize{api:staggering}}
Staggering is a finite difference technique in which the values of different
physical quantities are placed at different locations within a grid cell.

The ESMF {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} class supports a variety of stagger locations, including cell
centers, corners, and edge centers. The default stagger location in ESMF is the
cell center, and cell counts in {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} are based on this assumption. Combinations
of the 2D ESMF stagger locations are sufficient to specify any of the Arakawa
staggers. ESMF also supports staggering in 3D and higher dimensions. There are
shortcuts for standard staggers, and interfaces through which users can create
custom staggers.

As a default the ESMF {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} class provides symmetric staggering, so that cell
centers are enclosed by cell perimeter (e.g. corner) stagger locations. This
means the coordinate arrays for stagger locations other than the center will
have an additional element of padding in order to enclose the cell center
locations. However, to achieve other types of staggering, the user may alter or
eliminate this padding by using the appropriate options when adding coordinates
to a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} staggers are indicated using
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StaggerLoc}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Spherical Coordinates}
\label{\detokenize{api:spherical-coordinates}}
In the case that the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} is on a sphere (coord\_sys = {\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_DEG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ESMF.api.constants.CoordSys.SPH\_DEG}}}}} or
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_RAD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ESMF.api.constants.CoordSys.SPH\_RAD}}}}}) then the coordinates given in the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} are interpreted
as latitude and longitude values. The coordinates can either be in degrees or
radians as indicated by the \sphinxcode{\sphinxupquote{coord\_sys}} flag set during {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} creation. As is
true with many global models, this application currently assumes the latitude
and longitude refer to positions on a perfect sphere.

The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} coordinate system is represented using
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CoordSys}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,}
                    \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Periodicity}
\label{\detokenize{api:periodicity}}
A periodic connection can be specified when building {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grids}}}}} in spherical
coordinates. The \sphinxcode{\sphinxupquote{num\_peri\_dims}} parameter indicates the total number of
periodic dimensions and \sphinxcode{\sphinxupquote{periodic\_dim}} is used to identify which dimensions
should be considered periodic. There must always be at least one non-periodic
dimension. For example, to create a global latitude-longitude {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} there would
be one periodic dimension, dimension 0 (longitude).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,}
                    \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,}
                    \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Pole Generation}
\label{\detokenize{api:pole-generation}}
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} can generate an artificial pole by using the \sphinxcode{\sphinxupquote{pole\_dim}} parameter. This
can be helpful for regridding operations to smooth out the interpolated values
in the polar region. For the example of creating a global latitude-longitude
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, the pole dimension would be 1 (latitude).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,}
                    \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,}
                    \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pole\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Masking}
\label{\detokenize{api:masking}}
Masking is the process used to mark parts of a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} to be ignored during an
operation. Marking {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cells as masked can affect the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} values that are
represented by those cells. Masking is specified by assigning an integer value
to a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell. This allows many different masks to be defined on the same {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}},
any combination of which may be also activated on the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} by specifying the
corresponding integer values. The activation of {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} masks with respect to the
underlying {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} mask is handled by {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}, and a more
general discussion of masking is covered in the {\hyperref[\detokenize{api:id8}]{\sphinxcrossref{\DUrole{std,std-ref}{masking}}}}
section.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{k+kn}{import} \PYG{n+nn}{ESMF}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}                                \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}                                \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pole\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{mask} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{add\PYGZus{}item}\PYG{p}{(}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{GridItem}\PYG{o}{.}\PYG{n}{MASK}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{mask}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{int32}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Cell Areas}
\label{\detokenize{api:cell-areas}}
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell areas can be calculated by ESMPy. Space must first be allocated for
this calculation by adding an
{\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem.AREA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{AREA}}}}} item to the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.
Then a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} must be created, and the
{\hyperref[\detokenize{field:ESMF.api.field.Field.get_area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_area()}}}}} function called.

\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} area calculation assumes the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} is a unit sphere.
\end{sphinxadmonition}

{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell areas may also be set to user-defined values
after the {\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem.AREA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{AREA}}}}} item has
been allocated and retrieved using {\hyperref[\detokenize{grid:ESMF.api.grid.Grid.get_item}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_item()}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:} \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{,} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{]}\PYG{p}{,}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}                  \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{,}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}                  \PYG{n}{num\PYGZus{}peri\PYGZus{}dims}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pole\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLon} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLat} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLonCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLatCorner} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CORNER}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lon} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{120}\PYG{p}{,}\PYG{l+m+mi}{120}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{67.5}\PYG{p}{,} \PYG{l+m+mf}{67.5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lon\PYGZus{}corner} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{180}\PYG{p}{,}\PYG{l+m+mi}{180}\PYG{p}{,}\PYG{l+m+mi}{120}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lat\PYGZus{}corner} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lonm}\PYG{p}{,} \PYG{n}{latm} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{indexing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ij}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lonm\PYGZus{}corner}\PYG{p}{,} \PYG{n}{latm\PYGZus{}corner} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{lon\PYGZus{}corner}\PYG{p}{,} \PYG{n}{lat\PYGZus{}corner}\PYG{p}{,} \PYG{n}{indexing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ij}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLon}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lonm}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLat}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{latm}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLonCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lonm\PYGZus{}corner}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLatCorner}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{latm\PYGZus{}corner}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{field} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{field}\PYG{o}{.}\PYG{n}{get\PYGZus{}area}\PYG{p}{(}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{field}\PYG{o}{.}\PYG{n}{data}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{0.32224085}\PYG{p}{,}  \PYG{l+m+mf}{1.02707409}\PYG{p}{,}  \PYG{l+m+mf}{1.02707409}\PYG{p}{,}  \PYG{l+m+mf}{0.32224085}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[} \PYG{l+m+mf}{0.32224085}\PYG{p}{,}  \PYG{l+m+mf}{1.02707409}\PYG{p}{,}  \PYG{l+m+mf}{1.02707409}\PYG{p}{,}  \PYG{l+m+mf}{0.32224085}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[} \PYG{l+m+mf}{0.32224085}\PYG{p}{,}  \PYG{l+m+mf}{1.02707409}\PYG{p}{,}  \PYG{l+m+mf}{1.02707409}\PYG{p}{,}  \PYG{l+m+mf}{0.32224085}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Mesh}
\label{\detokenize{api:mesh}}
A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} is an object for representing unstructured grids. The ESMF reference
manual has an in-depth description of the
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION050100000000000000000}{Mesh class}.

A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} is constructed of \sphinxstyleemphasis{nodes} and \sphinxstyleemphasis{elements}. A node, also known as a vertex
or corner, is a part of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} which represents a single point. An element,
also known as a cell, is a part of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} which represents a small
region of space. Elements are described in terms of a connected set of nodes
which represent locations along their boundaries.

{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} data may be located on either the nodes or elements of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}}
created on a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can also be used as either the source or destination or both
of a regridding operation.

The dimension of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} in ESMF is specified with two parameters: the
\sphinxstyleemphasis{parametric} dimension and the \sphinxstyleemphasis{spatial} dimension.

The parametric dimension of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} is the dimension of the topology of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.
This can be thought of as the dimension of the elements which make up the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.
For example, a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} composed of triangles would have a parametric dimension of
2, and a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} composed of tetrahedra would have a parametric dimension of 3.

The spatial dimension of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} is the dimension of the space in which the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
is embedded. In other words, it is the number of coordinate dimensions needed to
describe the location of the nodes making up the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

For example, a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} constructed of squares on a plane would have a parametric
dimension of 2 and a spatial dimension of 2. If that same {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} were used to
represent the 2D surface of a sphere, then the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} would still have a
parametric dimension of 2, but now its spatial dimension would be 3.

Only {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}} whose number of coordinate dimensions (spatial dimension) is 2 or 3
are supported. The dimension of the elements in a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} (parametric dimension) must
be less than or equal to the spatial dimension, but also must be either 2 or 3.
This means that a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} may be either 2D elements in 2D space, 3D elements in 3D
space, or a manifold constructed of 2D elements embedded in 3D space.

For a parametric dimension of 2, the native supported element types are
triangles and quadrilaterals. In addition to these, ESMF supports 2D polygons
with any number of sides. Internally these are represented as sets of triangles,
but to the user should behave like any other element. For a parametric dimension
of 3, the supported element types are tetrahedrons and hexahedrons. The {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
supports any combination of element types within a particular dimension, but
types from different dimensions may not be mixed. For example, a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} cannot be
constructed of both quadrilaterals and tetrahedra.


\subsubsection{Mesh Creation}
\label{\detokenize{api:mesh-creation}}
To create a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} we need to set some properties of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} as a whole, some
properties of each node in the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} and then some properties of each element
which connects the nodes.

For the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} as a whole we set its parametric dimension and spatial dimension.
A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh's}}}}} parametric dimension can be thought of as the dimension of the elements
which make up the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh's}}}}} spatial dimension, on the other hand, is the
number of coordinate dimensions needed to describe the location of the nodes
making up the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

The structure of the per node and element information used to create a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} is
influenced by the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} distribution strategy. The {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} class is distributed by
elements. This means that a node must be present on any PET that contains
an element associated with that node, but not on any other PET (a node
can’t be on a PET without an element “home”). Since a node may be used by
two or more elements located on different PETs, a node may be duplicated
on multiple PETs. When a node is duplicated in this manner, one and only
one of the PETs that contain the node must “own” the node. The user sets
this ownership when they define the nodes during {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
creation. When a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} is created on a
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} (i.e. on the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} nodes),
on each PET the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} is only
created on the nodes which are owned by that PET. This means that the size
of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} memory on the PET can be smaller than the
number of nodes used to create the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} on that PET.

Three properties need to be defined for each {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} node: the global id of the node
(\sphinxcode{\sphinxupquote{node\_ids}}), node coordinates (\sphinxcode{\sphinxupquote{node\_coords}}), and which PET owns the node
(\sphinxcode{\sphinxupquote{node\_owners}}). The node id is a unique (across all PETs) integer attached
to the particular node. It is used to indicate which nodes are the same when
connecting together pieces of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} on different PETs. The node
coordinates indicate the location of a node in space and are used in the {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}
functionality when interpolating. The node owner indicates which PET is in
charge of the node. This is used when creating a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} on the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} to indicate
which PET should contain a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} location for the data.

Three properties need to be defined for each {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} element: the global id of the
element (\sphinxcode{\sphinxupquote{element\_ids}}), the topology type of the element (\sphinxcode{\sphinxupquote{element\_types}}), and
which nodes are connected together to form the element (\sphinxcode{\sphinxupquote{element\_conn}}). The
element id is a unique (across all PETs) integer attached to the
particular element. The element type describes the topology of the element
(e.g. a triangle vs. a quadrilateral). The range of choices for the topology of
the elements in a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} are restricted by the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh's}}}}} parametric dimension (e.g. a
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can’t contain a 2D element like a triangle, when its parametric dimension
is 3D), but it can contain any combination of elements appropriate to its
dimension. In particular, in 2D ESMF supports two native element types triangle
and quadrilateral, but also provides support for polygons with any number of
sides. These polygons are represented internally as sets of triangles, but to
the user should behave like other elements. To specify a polygon with more than
four sides, the element type should be set to the number of corners of the
polygon (e.g. element type=6 for a hexagon). The element connectivity indicates
which nodes are to be connected together to form the element. The number of
nodes connected together for each element is implied by the elements topology
type (\sphinxcode{\sphinxupquote{element\_types}}). It is IMPORTANT to note, that the entries in this list are
NOT the global ids of the nodes, but are indices into the PET local lists
of node info used in the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} creation. In other words, the element connectivity
isn’t specified in terms of the global list of nodes, but instead is specified
in terms of the locally described node info. One other important point about
connectivities is that the order of the nodes in the connectivity list of an
element is important. In general, when specifying an element with parametric
dimension 2, the nodes should be given in counterclockwise order around the
element.

The three step {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} creation process starts with a call to the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} constructor.
It is then followed by the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh.add_nodes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_nodes()}}}}} call to
specify nodes, and then the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh.add_elements}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_elements()}}}}} call to
specify elements.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}  2.5        8        10 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}11}
\PYG{c+c1}{\PYGZsh{}          /     \PYGZbs{}   /            \textbar{}}
\PYG{c+c1}{\PYGZsh{}  2.1   7         9              12}
\PYG{c+c1}{\PYGZsh{}        \textbar{}         \textbar{}      5       /}
\PYG{c+c1}{\PYGZsh{}        \textbar{}    4    \textbar{}            /}
\PYG{c+c1}{\PYGZsh{}        \textbar{}         \textbar{}          /}
\PYG{c+c1}{\PYGZsh{}  1.0   4 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 5 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 6}
\PYG{c+c1}{\PYGZsh{}        \textbar{}         \textbar{}  \PYGZbs{}   3  \textbar{}}
\PYG{c+c1}{\PYGZsh{}        \textbar{}    1    \textbar{}    \PYGZbs{}    \textbar{}}
\PYG{c+c1}{\PYGZsh{}        \textbar{}         \textbar{}  2   \PYGZbs{}  \textbar{}}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}0.1   1 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 2 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 3}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}      \PYGZhy{}0.1       1.0       2.1   2.5}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}          Node Ids at corners}
\PYG{c+c1}{\PYGZsh{}          Element Ids in centers}

\PYG{c+c1}{\PYGZsh{} Two parametric dimensions, and two spatial dimensions}
\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{n}{parametric\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{spatial\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}

\PYG{n}{num\PYGZus{}node} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{num\PYGZus{}elem} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{nodeId} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{nodeCoord} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 1}
                      \PYG{l+m+mf}{1.0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 2}
                      \PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 3}
                      \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 4}
                      \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 5}
                      \PYG{l+m+mf}{2.1}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 6}
                      \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{2.1}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 7}
                      \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 8}
                      \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.1}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 9}
                      \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 10}
                      \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{}node id 11}
                      \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}node id 12}


\PYG{n}{nodeOwner} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{num\PYGZus{}node}\PYG{p}{)}

\PYG{n}{elemId} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{elemType}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{QUAD}\PYG{p}{,}
                   \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{TRI}\PYG{p}{,}
                   \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{MeshElemType}\PYG{o}{.}\PYG{n}{TRI}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{elemConn}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}         \PYG{c+c1}{\PYGZsh{} elem id 1}
                   \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}           \PYG{c+c1}{\PYGZsh{} elem id 2}
                   \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}           \PYG{c+c1}{\PYGZsh{} elem id 3}
                   \PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}       \PYG{c+c1}{\PYGZsh{} elem id 4}
                   \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} elem id 5}

\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}nodes}\PYG{p}{(}\PYG{n}{num\PYGZus{}node}\PYG{p}{,}\PYG{n}{nodeId}\PYG{p}{,}\PYG{n}{nodeCoord}\PYG{p}{,}\PYG{n}{nodeOwner}\PYG{p}{)}

\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}elements}\PYG{p}{(}\PYG{n}{num\PYGZus{}elem}\PYG{p}{,}\PYG{n}{elemId}\PYG{p}{,}\PYG{n}{elemType}\PYG{p}{,}\PYG{n}{elemConn}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Masking}
\label{\detokenize{api:id1}}
There are two types of masking available in {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}: node masking and element
masking. These both work in a similar manner, but vary slightly in the details
of setting the mask information during {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} creation.

For node masking, the mask information is set using the \sphinxcode{\sphinxupquote{node\_mask}} parameter.
When a {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} object is created the mask values arguments \sphinxcode{\sphinxupquote{src\_mask\_values}} and
\sphinxcode{\sphinxupquote{dst\_mask\_values}} can then be used to indicate which particular values set in
the \sphinxcode{\sphinxupquote{node\_mask}} array indicate that the node should be masked. For example, if
\sphinxcode{\sphinxupquote{dst\_mask\_values}} has been set to 1, then any node in the destination {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} whose
corresponding \sphinxcode{\sphinxupquote{node\_mask}} value is 1 will be masked out (a node with any other
value than 1 will not be masked).

For element masking, the mask information is set using the \sphinxcode{\sphinxupquote{element\_mask}}
parameter when adding elements to the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. In a similar manner to node masking,
the mask values parameters to {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}, \sphinxcode{\sphinxupquote{src\_mask\_values}} and \sphinxcode{\sphinxupquote{dst\_mask\_values}}
can then be used to indicate which particular values set in the \sphinxcode{\sphinxupquote{element\_mask}}
array indicate that the element should be masked. For example, if
\sphinxcode{\sphinxupquote{dst\_mask\_values}} has been set to 1, then any element in the destination {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
whose corresponding \sphinxcode{\sphinxupquote{element\_mask}} value is 1 will be masked out (an element
with any other value than 1 will not be masked).


\subsubsection{Areas}
\label{\detokenize{api:areas}}
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} cell areas can be specified using the \sphinxcode{\sphinxupquote{element\_areas}} parameter to
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh.add_elements}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_elements()}}}}}.

If cell areas are not specified by the user they can be calculated by ESMPy
using {\hyperref[\detokenize{field:ESMF.api.field.Field.get_area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_area()}}}}}.


\subsection{LocStream}
\label{\detokenize{api:locstream}}
A {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} can be used to represent the locations of a set of
data points. For example, in the data assimilation world, {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStreams}}}}} can be used
to represent a set of observations. The values of the data points are stored
within a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} created using the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}. The ESMF reference
manual has an in-depth description of the
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05090000000000000000}{LocStream class}.

The locations are generally described using Cartesian (x, y, z), or
(lat, lon, radius) coordinates. The coordinates are stored using constructs
called \sphinxstyleemphasis{keys}. A key is essentially a list of point descriptors, one for each data
point. They may hold other information besides the coordinates - a mask, for
example. They may also hold a second set of coordinates. Keys are referenced by
name. Each key must contain the same number of elements as there are data points
in the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}. While there is no assumption in the ordering of the points,
the order chosen must be maintained in each of the keys.

A {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} can be very large. Data assimilation systems might use {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStreams}}}}}
with up to \(10^8\) observations, so efficiency is critical. {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStreams}}}}} can be
created from file.

A {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} is similar to a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} in that both are collections of irregularly
positioned points. However, the two structures differ because a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} also has
connectivity: each data point represents either a center or corner of a cell.
There is no requirement that the points in a {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} have connectivity, in
fact there is no requirement that any two points have any particular spatial
relationship at all.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{locstream} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{LocStream}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{n}{coord\PYGZus{}sys}\PYG{o}{=}\PYG{n}{coord\PYGZus{}sys}\PYG{p}{)}

\PYG{n}{deg\PYGZus{}rad} \PYG{o}{=} \PYG{n}{pi}
\PYG{k}{if} \PYG{n}{coord\PYGZus{}sys} \PYG{o}{==} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{CoordSys}\PYG{o}{.}\PYG{n}{SPH\PYGZus{}DEG}\PYG{p}{:}
    \PYG{n}{deg\PYGZus{}rad} \PYG{o}{=} \PYG{l+m+mi}{180}

\PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lon}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{]}
\PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Lat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{o}{*}\PYG{n}{deg\PYGZus{}rad}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{deg\PYGZus{}rad}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{]}
\PYG{k}{if} \PYG{n}{domask}\PYG{p}{:}
    \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Create a Grid or Mesh from File}
\label{\detokenize{api:create-a-grid-or-mesh-from-file}}

\subsection{File Formats}
\label{\detokenize{api:file-formats}}
ESMPy can create {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} or {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} objects from NetCDF files in a variety
of formats.  A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can be created from files in {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}}, {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.ESMFMESH}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ESMFMESH}}}}}, and {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}}
formats.  {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} files can be in {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} and {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}} format.


\subsubsection{SCRIP}
\label{\detokenize{api:scrip}}\phantomsection\label{\detokenize{api:id2}}
This file format is used by the {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} \sphinxcite{appendix:ref-scrip}, package, grid files that
work with that package should also work here.  {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} format files are
capable of storing either 2D logically rectangular grids or 2D
unstructured grids.  More information can be found in the ESMF reference
manual section on the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03028100000000000000}{SCRIP Grid File Format}.


\subsubsection{ESMFMESH}
\label{\detokenize{api:esmfmesh}}\phantomsection\label{\detokenize{api:id4}}
ESMF has a custom unstructured grid file format for describing {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}}.
This format is more compatible than the {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} format with the methods
used to create a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} object, so less conversion needs to be done to
create a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. The {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.ESMFMESH}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ESMFMESH}}}}} format is thus more efficient than {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} when
used with ESMPy.  More information can be found in the ESMF reference
manual section on the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03028200000000000000}{ESMF Unstructured Grid File Format}.


\subsubsection{GRIDSPEC}
\label{\detokenize{api:gridspec}}\phantomsection\label{\detokenize{api:id5}}
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}} is an extension to the Climate and Forecast (CF) metadata
conventions for the representation of gridded data for Earth System
Models.  ESMPy supports NetCDF files that follow the CF {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}}
convention to support logically rectangular lat/lon grids.  More
information can be found in the ESMF reference manual section on the
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03028300000000000000}{CF Convention GRIDSPEC File Format}.


\subsubsection{UGRID}
\label{\detokenize{api:ugrid}}\phantomsection\label{\detokenize{api:id6}}
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}} is an extension to the CF metadata
conventions for the unstructured grid data model.  ESMPy support
NetCDF files that follow the CF {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}} convention for unstructured grids.
More information can be found in the ESMF reference manual section on
the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node3.html\#SECTION03028400000000000000}{CF Convention UGRID File Format}.


\subsection{Meshes from File}
\label{\detokenize{api:meshes-from-file}}
When creating a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} from a {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} format file, there are a number of
options to control the output {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. The data is located at the center
of the grid cell in a {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} grid. Therefore, when the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} will be
part of a conservative regridding operation, the \sphinxcode{\sphinxupquote{convert\_to\_dual}}
flag must be set to True to properly generate coordinates at the the
cell corners.

A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} may also be created with boolean flags to specify whether or not to
add an area property to the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} \sphinxcode{\sphinxupquote{add\_user\_area}}, or to add a mask
\sphinxcode{\sphinxupquote{add\_mask}} held by the NetCDF variable indicated in the optional argument,
\sphinxcode{\sphinxupquote{varname}}.  These argument are only valid for {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}} formatted files.
The mask generated for a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} created from file will
have 0 for the masked values and 1 for the unmasked values.


\subsection{Grids from File}
\label{\detokenize{api:grids-from-file}}
A number of optional boolean arguments are also supported to create a
structured {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} from a file.  These include \sphinxcode{\sphinxupquote{is\_sphere}} to indicate whether
the grid is spherical or regional, \sphinxcode{\sphinxupquote{add\_corner\_stagger}} to add the corner
stagger information to the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} for conservative regridding, and
\sphinxcode{\sphinxupquote{add\_user\_area}} to specify whether to read in the cell area from the
NetCDF file or to calculate them.

For {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}} formated files
there is the \sphinxcode{\sphinxupquote{add\_mask}} optional argument
to add a mask held by the NetCDF variable indicated in optional
argument, \sphinxcode{\sphinxupquote{varname}}, and the \sphinxcode{\sphinxupquote{coord\_names}} argument to specify the longitude
and latitude variable names in a {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}} file containing multiple sets of
coordinates.

For {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}} formated files the integer array \sphinxcode{\sphinxupquote{grid\_imask}} is used to mask out grid cells which should not participate in the regridding.

The mask generated for a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} created from
file (any format) will have 0 for the masked values and 1 for the unmasked values.


\section{Regridding}
\label{\detokenize{api:regridding}}
The following table describe the regridding methods and options that are
available in ESMPy, the flag that is required to use it, a short description,
and an ESMF documentation reference.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Class
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Link
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.BILINEAR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BILINEAR}}}}}
&
Linear regridding in two dimensions
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012100000000000000}{Bilinear}
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.PATCH}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PATCH}}}}}
&
Higher-order least squares method
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012200000000000000}{Higher-order patch}
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.NEAREST_STOD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NEAREST\_STOD}}}}}
&
Nearest source point used for each destination
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012300000000000000}{Nearest source to destination}
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.NEAREST_DTOS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NEAREST\_DTOS}}}}}
&
Nearest destination point used for each source
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012400000000000000}{Nearest destination to source}
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE}}}}}
&
First-order conservative
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012500000000000000}{First-order conservative}
\\
\hline
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE_2ND}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE\_2ND}}}}}
&
Second-order conservative
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012600000000000000}{Second-order conservative}
\\
\hline
See conservative options above.
&
Conservation equations
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012700000000000000}{Conservation}
\\
\hline
{\hyperref[\detokenize{NormType:ESMF.api.constants.NormType}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NormType}}}}}
&
Normalization options for integral conservation
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012800000000000000}{Normalization options}
\\
\hline
{\hyperref[\detokenize{LineType:ESMF.api.constants.LineType}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LineType}}}}}
&
Line types for spherical and Cartesian space
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION05012900000000000000}{Great circle cells}
\\
\hline
{\hyperref[\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UnmappedAction}}}}}
&
Unmapped destination point handling options
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION050121500000000000000}{Unmapped destination points}
\\
\hline
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CoordSys}}}}}
&
Spherical grids and pole handling
&
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION050121600000000000000}{Spherical grids and poles}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Masking}
\label{\detokenize{api:id7}}\phantomsection\label{\detokenize{api:id8}}
Masking is the process whereby parts of a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} can be marked to be ignored
during an operation, such as when they are used in regridding. Masking can be used on a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
created from a regridding source to indicate that certain portions should not be used to generate
regridded data. This is useful, for example, if a portion of the source contains unusable values.
Masking can also be used on a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} created from a regridding destination to indicate that a certain
portion should not receive regridded data. This is useful, for example, when part of the destination
isn’t being used (e.g. the land portion of an ocean grid).

The user may mask out points in the source {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} or destination {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} or both. To do masking the user
sets mask information in the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} upon
which the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} passed into the {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} call are built. The \sphinxcode{\sphinxupquote{src\_mask\_values}} and
\sphinxcode{\sphinxupquote{dst\_mask\_values}} arguments to that call can then be used to specify which values in that mask information
indicate that a location should be masked out. For example, if \sphinxcode{\sphinxupquote{dst\_mask\_values}} is set to {[}1,2{]}, then any
location that has a value of 1 or 2 in the mask information of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} upon which
the destination {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} is built will be masked out.

Masking behavior differs slightly between regridding methods. For non-conservative regridding methods
(e.g. bilinear or high-order patch), masking is done on points. For these methods, masking a destination
point means that the point will not participate in regridding. For these
methods, masking a source point means that the entire source cell using that point is masked out.
In other words, if any corner point making up a source cell is masked then the cell is masked.
For conservative regridding methods masking is done on cells.
Masking a destination cell means that the cell won’t participate in regridding.
Similarly, masking a source cell means that the cell won’t participate in regridding.
For any type of interpolation method (conservative or non-conservative)
the masking is set on the location upon which the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} passed into the regridding call are built.
For example, if {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} built on
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StaggerLoc.CENTER}}}}} are passed into
{\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}
then the masking should also be set on {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StaggerLoc.CENTER}}}}}.

The mask generated for a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}},
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} created
from file will have 0 for the masked values and 1 for the unmasked values.


\section{Numpy Slicing and Indexing}
\label{\detokenize{api:numpy-slicing-and-indexing}}
Numpy arrays are used to represent {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} and {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} coordinates and {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} data,
among other things.  Standard numpy conventions for array indexing
and slicing can be expected.  There are some exceptions when it comes to fancy
indexing, index arrays, and multi-dimensional slicing.  Significant effort has
been put into raising exceptions where inappropriate indexing or slicing
operations are attempted.

It is very important to remember that all indexing
and slicing operations apply \sphinxstylestrong{ONLY} to the ESMPy level objects, and these operations
do not propagate down to the lower-level Fortran- and C-based representations
of the ESMF objects.  One example of where this could come up is when passing
a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} slice into regridding.  The entire original {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} will still be run
through the ESMF regridding engine, and only the appropriate portion of
the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} slice will be updated with the regridded values.


\subsection{Dimension Ordering}
\label{\detokenize{api:dimension-ordering}}
\begin{sphinxadmonition}{warning}{Warning:}
The underlying ESMF library is built with a mix of Fortran and C/C++
and follows Fortran conventions with respect to array indexing and
dimension ordering. Some effort has been made to make ESMPy feel more
natural to the Python user where possible. This means that ESMPy uses
0-based indexing, which is translated to the 1-based indexing used by
the ESMPy backend. However, the dimension ordering still follows
Fortran conventions. Namely, longitude comes before latitude, which
also comes before temporal dimensions when in use.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{k+kn}{import} \PYG{n+nn}{ESMF}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{grid} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Grid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{staggerloc}\PYG{o}{=}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLon} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLat} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{get\PYGZus{}coords}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lon} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{120}\PYG{p}{,}\PYG{l+m+mi}{120}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{67.5}\PYG{p}{,} \PYG{l+m+mf}{67.5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{lonm}\PYG{p}{,} \PYG{n}{latm} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{indexing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ij}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLon}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lonm}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:} \PYG{n}{gridLat}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{latm}
   \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{:}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{:} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{:} \PYG{n}{lon}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{:} \PYG{n}{lat}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{:} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{:}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{120.}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}   \PYG{l+m+mf}{0.}\PYG{p}{,}    \PYG{l+m+mf}{0.}\PYG{p}{,}    \PYG{l+m+mf}{0.}\PYG{p}{,}    \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[} \PYG{l+m+mf}{120.}\PYG{p}{,}  \PYG{l+m+mf}{120.}\PYG{p}{,}  \PYG{l+m+mf}{120.}\PYG{p}{,}  \PYG{l+m+mf}{120.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{:} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{StaggerLoc}\PYG{o}{.}\PYG{n}{CENTER}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{:}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{67.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{22.5}\PYG{p}{,}  \PYG{l+m+mf}{22.5}\PYG{p}{,}  \PYG{l+m+mf}{67.5}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{67.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{22.5}\PYG{p}{,}  \PYG{l+m+mf}{22.5}\PYG{p}{,}  \PYG{l+m+mf}{67.5}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{67.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{22.5}\PYG{p}{,}  \PYG{l+m+mf}{22.5}\PYG{p}{,}  \PYG{l+m+mf}{67.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{:} \PYG{n}{field} \PYG{o}{=} \PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{Field}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,} \PYG{n}{ndbounds}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a Field with a time dimension}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{:} \PYG{n}{field}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Parallel Execution}
\label{\detokenize{api:parallel-execution}}
ESMPy is a thin wrapper on top of ESMF, which was designed for high performance
and scalable computing. The ESMF virtual machine is used to manage the available
resources of the execution environment in a layer that is transparent to the
ESMPy user. This allows the full power of the high performance computing
environment to be utilized by the ESMPy user with little use of specialized
parallel programming techniques.

ESMPy objects will be distributed across the available computing resources with
no additional parameters required. The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}, and {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} classes
will all be transparently “parallelized” with no need for user calls to a
message passing interface. Likewise, the {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} class will compute and apply
the interpolation weights using all available computing resources with no need
for user intervention.

However, it is useful to remember that resulting {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} values will only be
accessible on certain PETs. The mpi4py package may be necessary for post
processing tasks that require access to global {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} values.


\subsection{mpirun vs. MPI.Spawn}
\label{\detokenize{api:mpirun-vs-mpi-spawn}}
There are a few different options for using ESMPy in a parallel
environment. Using mpirun to specify the desired number of computing cores
is probably the easiest way to start a parallel ESMPy job. Another option is to
call the MPI.Spawn() function from the mpi4py Python package from within a
serial Python script or interpreter. It has been observed that MPI.Spawn() may
not work properly when mpi4py is built with an underlying mpich
library, openmpi has seen better success. A third option is to call mpirun
using a system call from within a serial Python script or interpreter, however
this method is not highly recommended.

The following two examples demonstrate how to execute an ESMPy script in
parallel. Any of the scripts found in the examples directory of the ESMPy source
code can be run in parallel using mpirun as well as in serial mode.


\subsubsection{mpirun}
\label{\detokenize{api:mpirun}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{4} \PYG{n}{python} \PYG{n}{hello\PYGZus{}world}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}


\subsubsection{MPI.Spawn}
\label{\detokenize{api:mpi-spawn}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{mpi4py} \PYG{k}{import} \PYG{n}{MPI}

\PYG{c+c1}{\PYGZsh{} Parent}
\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Spawn workers}
    \PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}\PYG{o}{.}\PYG{n}{Spawn}\PYG{p}{(}
        \PYG{n}{sys}\PYG{o}{.}\PYG{n}{executable}\PYG{p}{,}
        \PYG{n}{args}\PYG{o}{=}\PYG{p}{[}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{worker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{maxprocs}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Shutdown}
    \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Disconnect}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Worker}
\PYG{k}{elif} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{worker}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Connect to parent}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{Comm}\PYG{o}{.}\PYG{n}{Get\PYGZus{}parent}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{rank} \PYG{o}{=} \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Get\PYGZus{}rank}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Could not connect to parent \PYGZhy{} }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{usage}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} worker code goes here, regridding etc..}
    \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World from PET \PYGZsh{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{rank}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Shutdown}
    \PYG{n}{comm}\PYG{o}{.}\PYG{n}{Disconnect}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Catch}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Program should be started without arguments}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

A more detailed example of using MPI.Spawn() can be found in the Tutorials section
of the documentation.


\chapter{Appendices}
\label{\detokenize{appendix:appendices}}\label{\detokenize{appendix::doc}}

\section{Class APIs}
\label{\detokenize{appendix:class-apis}}

\subsection{Manager}
\label{\detokenize{manager:manager}}\label{\detokenize{manager::doc}}\index{Manager (class in ESMF.api.esmpymanager)@\spxentry{Manager}\spxextra{class in ESMF.api.esmpymanager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{manager:ESMF.api.esmpymanager.Manager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.esmpymanager.}}\sphinxbfcode{\sphinxupquote{Manager}}}{\emph{debug=False}}{}
This singleton class is designed to ensure that ESMF is properly initialized 
and finalized.  ESMF is initialized at 
{\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} creation, and the \_\_del\_\_ 
method is registered with atexit to ensure ESMF is always finalized prior to 
exiting Python.  If the object is copied, the copy will always be an alias 
to the original {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} object.  The 
{\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} will be created when the first 
ESMPy object is created if it is not created explicitly by the user.

Explicit creation of a {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} object allows
for setting a flag which 
results in the output of debug information from the ESMF logging capability 
during the application runtime.  The output log files are named 
PET\textless{}PET number\textgreater{}.ESMF\_LogFile.

The PET rank (local\_pet) and total number of PETs (pet\_count) 
can also be retrieved from the {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} 
using the following calls:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{local\PYGZus{}pet}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ESMF}\PYG{o}{.}\PYG{n}{pet\PYGZus{}count}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{local\_pet}} and \sphinxcode{\sphinxupquote{pet\_count}} are also properties of the 
{\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}}.

Calls ESMP\_Initialize and registers \_\_del\_\_ with atexit when called the
first time.  Subsequent calls only return whether or not ESMF is
initialized.  Registering \_\_del\_\_ with atexit ensures the ESMP\_Finalize
will always be called prior to exiting Python.  Calling \_\_init\_\_
explicitly results in a no-op.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{debug}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} outputs logging information to ESMF logfiles. If
\sphinxcode{\sphinxupquote{None}}, defaults to False.

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Field}
\label{\detokenize{field:field}}\label{\detokenize{field::doc}}\index{Field (class in ESMF.api.field)@\spxentry{Field}\spxextra{class in ESMF.api.field}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.field.}}\sphinxbfcode{\sphinxupquote{Field}}}{\emph{**kwargs}}{}
The {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} class is a Python wrapper object for the ESMF Field.
The individual values of all data arrays are referenced to those of the
underlying Fortran ESMF object.

A {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} represents a physical field, such as temperature.   The {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} class
contains distributed and discretized field data, a reference to its
associated grid, and metadata. The {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} class stores the grid staggering
for that physical field. This is the relationship of how the data array of
a field maps onto a grid (e.g. one item per cell located at the cell center,
one item per cell located at the NW corner, one item per cell vertex, etc.).
This means that different {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} which are on the same underlying {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} but
have different staggerings can share the same {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} object without needing to
replicate it multiple times.

For more information about the ESMF Field class, please see the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_7\_1\_0r/ESMF\_refdoc/node5.html\#SECTION05030000000000000000}{ESMF Field documentation}.

The following parameters are used to create a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
from a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\sphinxstyleemphasis{REQUIRED:}
\begin{description}
\item[{:param {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}/Mesh/{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} grid: A {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}},}] \leavevmode
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}
with coordinates allocated on at least one stagger location.

\end{description}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} An optional user friendly name for the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{typekind}} ({\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TypeKind}}}}}) \textendash{} Type of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
data. If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind.R8}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{R8}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{staggerloc}} ({\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StaggerLoc}}}}}) \textendash{} The stagger location of the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} data, only specify this argument when
using a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER}}}}}
in 2D and {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER\_VCENTER}}}}} in 3D.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{meshloc}} ({\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{MeshLoc}}}}}) \textendash{} The mesh location of the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} data, only specify this argument when
using a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
if \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc.NODE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NODE}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ndbounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} The number of entries in an extra
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} dimension. This is represented as a
single value, a list or a tuple containing the number of entries for
each desired extra dimension of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}. The
time dimension must be last, following Fortran indexing conventions.

\end{itemize}

\end{description}\end{quote}
\index{data (ESMF.api.field.Field attribute)@\spxentry{data}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.data}}\pysigline{\sphinxbfcode{\sphinxupquote{data}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TypeKind}}}}}

\item[{Returns}] \leavevmode
The data of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{grid (ESMF.api.field.Field attribute)@\spxentry{grid}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.grid}}\pysigline{\sphinxbfcode{\sphinxupquote{grid}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, or
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}

\item[{Returns}] \leavevmode
The discretization object upon which the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} is built.

\end{description}\end{quote}

\end{fulllineitems}

\index{lower\_bounds (ESMF.api.field.Field attribute)@\spxentry{lower\_bounds}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.lower_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{lower\_bounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
ndarray

\item[{Returns}] \leavevmode
The lower bounds of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{name (ESMF.api.field.Field attribute)@\spxentry{name}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{str}

\item[{Returns}] \leavevmode
the name of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{ndbounds (ESMF.api.field.Field attribute)@\spxentry{ndbounds}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.ndbounds}}\pysigline{\sphinxbfcode{\sphinxupquote{ndbounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
list

\item[{Returns}] \leavevmode
The bounds of the extra dimensions in the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{rank (ESMF.api.field.Field attribute)@\spxentry{rank}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.rank}}\pysigline{\sphinxbfcode{\sphinxupquote{rank}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The rank of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{staggerloc (ESMF.api.field.Field attribute)@\spxentry{staggerloc}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.staggerloc}}\pysigline{\sphinxbfcode{\sphinxupquote{staggerloc}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StaggerLoc}}}}} or
{\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshLoc}}}}}

\item[{Returns}] \leavevmode
The location upon which the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
is built.

\end{description}\end{quote}

\end{fulllineitems}

\index{type (ESMF.api.field.Field attribute)@\spxentry{type}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.type}}\pysigline{\sphinxbfcode{\sphinxupquote{type}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TypeKind}}}}}

\item[{Returns}] \leavevmode
The type of the data in the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{upper\_bounds (ESMF.api.field.Field attribute)@\spxentry{upper\_bounds}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.upper_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{upper\_bounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
ndarray

\item[{Returns}] \leavevmode
The upper bounds of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{xd (ESMF.api.field.Field attribute)@\spxentry{xd}\spxextra{ESMF.api.field.Field attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.xd}}\pysigline{\sphinxbfcode{\sphinxupquote{xd}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The number of extra (ungridded) dimensions of the
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (ESMF.api.field.Field method)@\spxentry{copy()}\spxextra{ESMF.api.field.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} in an ESMF-safe manner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} shallow copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{destroy() (ESMF.api.field.Field method)@\spxentry{destroy()}\spxextra{ESMF.api.field.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.destroy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{destroy}}}{}{}
Release the memory associated with a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\end{fulllineitems}

\index{get\_area() (ESMF.api.field.Field method)@\spxentry{get\_area()}\spxextra{ESMF.api.field.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.get_area}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_area}}}{}{}
Initialize an existing {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} with the areas of
the cells of the underlying {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} or
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{fulllineitems}

\index{read() (ESMF.api.field.Field method)@\spxentry{read()}\spxextra{ESMF.api.field.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{field:ESMF.api.field.Field.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{\emph{filename}, \emph{variable}, \emph{timeslice=None}}{}
Read data into an existing {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} from a
CF-compliant NetCDF file.
\begin{quote}\begin{description}
\item[{Note}] \leavevmode
This interface is not supported when ESMF is built with
\sphinxcode{\sphinxupquote{ESMF\_COMM=mpiuni}}.

\item[{Note}] \leavevmode
This interface does not currently support reading ungridded 
dimensions.

\end{description}\end{quote}

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The name of the NetCDF file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variable}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The name of the data variable to read from file.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{timeslice}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} The number of timeslices to read.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Grid}
\label{\detokenize{grid:grid}}\label{\detokenize{grid::doc}}\index{Grid (class in ESMF.api.grid)@\spxentry{Grid}\spxextra{class in ESMF.api.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.grid.}}\sphinxbfcode{\sphinxupquote{Grid}}}{\emph{**kwargs}}{}
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} class is a Python wrapper object for the ESMF Grid.  The individual 
values of all coordinate and mask arrays are referenced to those of the
underlying Fortran ESMF object.

The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} class is used to describe the geometry and
discretization of logically rectangular physical grids.  It also contains
the description of the underlying topology and decomposition of the physical
grid across the available computational resources. The most frequent use of
the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} class is to describe physical grids in user
code so that sufficient information is available to perform regridding
operations.

For more information about the ESMF Grid class, please see the 
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_7\_1\_0r/ESMF\_refdoc/node5.html\#SECTION05080000000000000000}{ESMF Grid documentation}.

A {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} can be created in two different ways, as a
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} in memory, or from SCRIP formatted or CF compliant GRIDSPEC file. The
arguments for each type of {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} creation are
outlined below.

\sphinxstylestrong{Created in-memory:}

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{max\_index}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} An integer list of length 2 or 3, with the
number of grid cells in each dimension.

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_peri\_dims}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The number of periodic dimensions, either \sphinxcode{\sphinxupquote{0}}
or \sphinxcode{\sphinxupquote{1}}. If \sphinxcode{\sphinxupquote{None}}, defaults to \sphinxcode{\sphinxupquote{0}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{periodic\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The periodic dimension: \sphinxcode{\sphinxupquote{0}}, \sphinxcode{\sphinxupquote{1}} or \sphinxcode{\sphinxupquote{2}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to \sphinxcode{\sphinxupquote{0}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pole\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The pole dimension \sphinxcode{\sphinxupquote{0}} or \sphinxcode{\sphinxupquote{1}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} ({\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CoordSys}}}}}) \textendash{} Coordinate system for the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_DEG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SPH\_DEG}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_typekind}} ({\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TypeKind}}}}}) \textendash{} Type of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
coordinates.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind.R8}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{R8}}}}}.

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Created either from file or in-memory:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{staggerloc}} ({\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StaggerLoc}}}}}) \textendash{} The stagger location of the coordinate values.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER}}}}}
in 2D and {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER\_VCENTER}}}}} in 3D.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pole\_kind}} ({\hyperref[\detokenize{PoleKind:ESMF.api.constants.PoleKind}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PoleKind}}}}}) \textendash{} Two item list which specifies the type of
connection which occurs at the pole. The first value specifies the
connection that occurs at the minimum end of the pole dimension. 
The second value specifies the connection that occurs at the maximum 
end of the pole dimension.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{PoleKind:ESMF.api.constants.PoleKind.MONOPOLE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MONOPOLE}}}}}.

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Created from file:}

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The name of the NetCDF grid file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filetype}} ({\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{FileFormat}}}}}) \textendash{} The grid {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FileFormat}}}}}.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is\_sphere}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Set to \sphinxcode{\sphinxupquote{True}} for a spherical grid, or \sphinxcode{\sphinxupquote{False}}
for regional. Defaults to \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{add\_corner\_stagger}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Set to \sphinxcode{\sphinxupquote{True}} to use the information in
the grid file to add the corner stagger to the grid. The coordinates for
the corner stagger are required for conservative regridding. If
not specified, defaults to \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{add\_user\_area}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Set to \sphinxcode{\sphinxupquote{True}} to read in the cell area from the
grid file; otherwise, ESMF will calculate it. Defaults to \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{add\_mask}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Set to \sphinxcode{\sphinxupquote{True}} to generate the mask using the
\sphinxcode{\sphinxupquote{missing\_value}} attribute defined in \sphinxcode{\sphinxupquote{varname}}.  This argument is
only supported with filetype
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}}.
Defaults to \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{varname}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} If add\_mask is \sphinxcode{\sphinxupquote{True}}, provide a variable name stored
in the grid file and the mask will be generated using the missing value
of the data value of this variable.  The first two dimensions of the
variable has to be the longitude and the latitude dimension and the
mask is derived from the first 2D values of this variable even if this
data is a 3D, or 4D array. This argument is only supported with
filetype {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}}.
Defaults to \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_names}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} A two-element array containing the longitude and
latitude variable names in a GRIDSPEC file if there are multiple
coordinates defined in the file. This argument is only supported with
filetype {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GRIDSPEC}}}}}.
Defaults to \sphinxcode{\sphinxupquote{None}}.

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Cubed sphere:}

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{tilesize}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The number of elements on each side of the tile of the
cubed sphere grid.

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{regDecompPTile}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} List of DE counts for each dimension. The second index steps through
the tiles. The total deCount is determined as the sum over
the products of regDecompPTile elements for each tile.
By default every tile is decomposed in the same way.  If the total
PET count is less than 6, one tile will be assigned to one DE and the DEs
will be assigned to PETs sequentially, therefore, some PETs may have
more than one DE. If the total PET count is greater than 6, the total
number of DEs will be a multiple of 6 and less than or equal to the total
PET count. For instance, if the total PET count is 16, the total DE count
will be 12 with each tile decomposed into 1x2 blocks. The 12 DEs are mapped
to the first 12 PETs and the remaining 4 PETs have no DEs locally.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The name of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{itemize}

\end{description}\end{quote}
\index{area (ESMF.api.grid.Grid attribute)@\spxentry{area}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.area}}\pysigline{\sphinxbfcode{\sphinxupquote{area}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A list of numpy arrays with an entry for every stagger location
of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\item[{Returns}] \leavevmode
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell areas represented as
numpy arrays of floats of size given by
\sphinxcode{\sphinxupquote{upper\_bounds - lower\_bounds}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{areatype (ESMF.api.grid.Grid attribute)@\spxentry{areatype}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.areatype}}\pysigline{\sphinxbfcode{\sphinxupquote{areatype}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TypeKind}}}}}

\item[{Returns}] \leavevmode
The ESMF typekind of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell
areas.

\end{description}\end{quote}

\end{fulllineitems}

\index{coords (ESMF.api.grid.Grid attribute)@\spxentry{coords}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.coords}}\pysigline{\sphinxbfcode{\sphinxupquote{coords}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
2D list of numpy arrays of size given by
\sphinxcode{\sphinxupquote{upper\_bounds - lower\_bounds}}, where the first index represents
the stagger locations of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} and the
second index represent the coordinate dimensions of the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\item[{Returns}] \leavevmode
The coordinates of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{coord\_sys (ESMF.api.grid.Grid attribute)@\spxentry{coord\_sys}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.coord_sys}}\pysigline{\sphinxbfcode{\sphinxupquote{coord\_sys}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CoordSys}}}}}

\item[{Returns}] \leavevmode
The coordinate system of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_corners (ESMF.api.grid.Grid attribute)@\spxentry{has\_corners}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.has_corners}}\pysigline{\sphinxbfcode{\sphinxupquote{has\_corners}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{bool}

\item[{Returns}] \leavevmode
A boolean value to tell if the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
has corners allocated.

\end{description}\end{quote}

\end{fulllineitems}

\index{lower\_bounds (ESMF.api.grid.Grid attribute)@\spxentry{lower\_bounds}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.lower_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{lower\_bounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A list of numpy arrays with an entry for every stagger location
of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\item[{Returns}] \leavevmode
The lower bounds of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
represented as numpy arrays of ints of size given by
\sphinxcode{\sphinxupquote{upper\_bounds - lower\_bounds}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{mask (ESMF.api.grid.Grid attribute)@\spxentry{mask}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.mask}}\pysigline{\sphinxbfcode{\sphinxupquote{mask}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A list of numpy arrays with an entry for every stagger location
of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\item[{Returns}] \leavevmode
The mask of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} represented as
numpy arrays of ints of size given by {}`
\sphinxtitleref{upper\_bounds - lower\_bounds{}`}.

\end{description}\end{quote}

\end{fulllineitems}

\index{max\_index (ESMF.api.grid.Grid attribute)@\spxentry{max\_index}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.max_index}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_index}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A numpy array with as many values as the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} rank.

\item[{Returns}] \leavevmode
The number of {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cells in each
dimension of the grid.

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_peri\_dims (ESMF.api.grid.Grid attribute)@\spxentry{num\_peri\_dims}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.num_peri_dims}}\pysigline{\sphinxbfcode{\sphinxupquote{num\_peri\_dims}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The total number of periodic dimensions in the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{periodic\_dim (ESMF.api.grid.Grid attribute)@\spxentry{periodic\_dim}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.periodic_dim}}\pysigline{\sphinxbfcode{\sphinxupquote{periodic\_dim}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The periodic dimension of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
(e.g. \sphinxcode{\sphinxupquote{0}} for \sphinxcode{\sphinxupquote{x}} or \sphinxcode{\sphinxupquote{longitude}}, \sphinxcode{\sphinxupquote{1}} for \sphinxcode{\sphinxupquote{y}} or
\sphinxcode{\sphinxupquote{latitude}}, etc.).

\end{description}\end{quote}

\end{fulllineitems}

\index{pole\_dim (ESMF.api.grid.Grid attribute)@\spxentry{pole\_dim}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.pole_dim}}\pysigline{\sphinxbfcode{\sphinxupquote{pole\_dim}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The pole dimension of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
(e.g. \sphinxcode{\sphinxupquote{0}} for \sphinxcode{\sphinxupquote{x}} or \sphinxcode{\sphinxupquote{longitude}}, \sphinxcode{\sphinxupquote{1}} for \sphinxcode{\sphinxupquote{y}} or
\sphinxcode{\sphinxupquote{latitude}}, etc.).

\end{description}\end{quote}

\end{fulllineitems}

\index{rank (ESMF.api.grid.Grid attribute)@\spxentry{rank}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.rank}}\pysigline{\sphinxbfcode{\sphinxupquote{rank}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The rank of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{size (ESMF.api.grid.Grid attribute)@\spxentry{size}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.size}}\pysigline{\sphinxbfcode{\sphinxupquote{size}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A list of numpy arrays with an entry for every stagger location
of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\item[{Returns}] \leavevmode
The size of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} represented as
numpy arrays of ints of size given by
\sphinxcode{\sphinxupquote{upper\_bounds - lower\_bounds}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{staggerloc (ESMF.api.grid.Grid attribute)@\spxentry{staggerloc}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.staggerloc}}\pysigline{\sphinxbfcode{\sphinxupquote{staggerloc}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
list of bools

\item[{Returns}] \leavevmode
The stagger locations that have been allocated for the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{type (ESMF.api.grid.Grid attribute)@\spxentry{type}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.type}}\pysigline{\sphinxbfcode{\sphinxupquote{type}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TypeKind}}}}}

\item[{Returns}] \leavevmode
The ESMF typekind of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
coordinates.

\end{description}\end{quote}

\end{fulllineitems}

\index{upper\_bounds (ESMF.api.grid.Grid attribute)@\spxentry{upper\_bounds}\spxextra{ESMF.api.grid.Grid attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.upper_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{upper\_bounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A list of numpy arrays with an entry for every stagger location
of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\item[{Returns}] \leavevmode
The upper bounds of the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}
represented as numpy arrays of ints of size given by
\sphinxcode{\sphinxupquote{upper\_bounds - lower\_bounds}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_coords() (ESMF.api.grid.Grid method)@\spxentry{add\_coords()}\spxextra{ESMF.api.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.add_coords}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_coords}}}{\emph{staggerloc=None}, \emph{coord\_dim=None}, \emph{from\_file=False}}{}
Add coordinates to the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} at the specified
stagger location.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{staggerloc}} ({\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StaggerLoc}}}}}) \textendash{} The stagger location of the coordinate
values. If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER}}}}}
in 2D and {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER\_VCENTER}}}}} in
3D.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The dimension number of the coordinates to return
e.g. \sphinxcode{\sphinxupquote{{[}x, y, z{]} = (0, 1, 2)}}, or \sphinxcode{\sphinxupquote{{[}lon, lat{]} = (0, 1)}}
(coordinates will not be returned if coord\_dim is not specified and
staggerlocs is a list with more than one element).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{from\_file}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Boolean for internal use to determine whether the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} has already been created from file.

\end{itemize}

\item[{Returns}] \leavevmode
A numpy array of coordinate values if staggerloc and
coord\_dim are specified, otherwise return None.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_item() (ESMF.api.grid.Grid method)@\spxentry{add\_item()}\spxextra{ESMF.api.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.add_item}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_item}}}{\emph{item}, \emph{staggerloc=None}, \emph{from\_file=False}}{}
Allocate space for a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} item (mask or areas)
at a specified stagger location.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{item}} ({\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{GridItem}}}}}) \textendash{} The {\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GridItem}}}}} to
allocate.

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{staggerloc}} ({\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StaggerLoc}}}}}) \textendash{} The stagger location of the item
values. If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER}}}}}
in 2D and {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER\_VCENTER}}}}} in
3D.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{from\_file}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Boolean for internal use to determine whether the
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} has already been created from file.

\end{itemize}

\item[{Returns}] \leavevmode
A numpy array of the mask or area values if a single
staggerloc is given, otherwise return None.

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (ESMF.api.grid.Grid method)@\spxentry{copy()}\spxextra{ESMF.api.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} in an ESMF-safe manner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} shallow copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{destroy() (ESMF.api.grid.Grid method)@\spxentry{destroy()}\spxextra{ESMF.api.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.destroy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{destroy}}}{}{}
Release the memory associated with a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{fulllineitems}

\index{get\_coords() (ESMF.api.grid.Grid method)@\spxentry{get\_coords()}\spxextra{ESMF.api.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.get_coords}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_coords}}}{\emph{coord\_dim}, \emph{staggerloc=None}}{}
Return a numpy array of coordinates at a specified stagger 
location. The returned array is NOT a copy, it is
directly aliased to the underlying memory allocated by ESMF.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coord\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The dimension number of the coordinates to return
e.g. \sphinxcode{\sphinxupquote{{[}x, y, z{]} = (0, 1, 2)}}, or \sphinxcode{\sphinxupquote{{[}lon, lat{]} = (0, 1)}}
(coordinates will not be returned if \sphinxcode{\sphinxupquote{coord\_dim}} is not specified
and \sphinxcode{\sphinxupquote{staggerlocs}} is a list with more than one element).

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{staggerloc}} ({\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StaggerLoc}}}}}) \textendash{} The stagger location of the coordinate
values. If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER}}}}}
in 2D and {\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER\_VCENTER}}}}} in
3D.

\item[{Returns}] \leavevmode
A numpy array of coordinate values at the specified staggerloc.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_item() (ESMF.api.grid.Grid method)@\spxentry{get\_item()}\spxextra{ESMF.api.grid.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{grid:ESMF.api.grid.Grid.get_item}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_item}}}{\emph{item}, \emph{staggerloc=None}}{}
Return a numpy array of item values at a specified stagger
location.  The returned array is NOT a copy, it is
directly aliased to the underlying memory allocated by ESMF.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{item}} ({\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{GridItem}}}}}) \textendash{} The {\hyperref[\detokenize{GridItem:ESMF.api.constants.GridItem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GridItem}}}}} to
return.

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{staggerloc}} ({\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StaggerLoc}}}}}) \textendash{} The stagger location of the item
values. If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER}}}}} in 2D and
{\hyperref[\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CENTER\_VCENTER}}}}} in 3D.

\item[{Returns}] \leavevmode
A numpy array of mask or area values at the specified staggerloc.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Mesh}
\label{\detokenize{mesh:mesh}}\label{\detokenize{mesh::doc}}\index{Mesh (class in ESMF.api.mesh)@\spxentry{Mesh}\spxextra{class in ESMF.api.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.mesh.}}\sphinxbfcode{\sphinxupquote{Mesh}}}{\emph{**kwargs}}{}
The {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} class is a Python wrapper object for the ESMF Mesh.
The individual values of all coordinate and mask arrays are referenced to
those of the underlying Fortran ESMF object.

The ESMF library provides a class for representing unstructured grids called
the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} can be created on a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} to hold data. {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} created on a
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can also be used as either the source or destination or both of a
regrididng operation which allows data to be moved between unstructured
grids.  A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} is constructed of nodes and elements. A node, also known as
a vertex or corner, is a part of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} which represents a single point.
Coordinate information is set in a node. An element, also known as a cell,
is a part of a mesh which represents a small region of space. Elements are
described in terms of a connected set of nodes which represent locations
along their boundaries. {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} data may be located on either the nodes or
elements of a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

For more information about the ESMF Mesh class, please see the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_7\_1\_0r/ESMF\_refdoc/node5.html\#SECTION050100000000000000000}{ESMF Mesh
documentation}.

An unstructured {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can be created in two different ways, as a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} in
memory, or from a SCRIP formatted or CF compliant UGRID file. The arguments
for each type of {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} creation are outlined below.

\sphinxstylestrong{Created in-memory:}
\begin{description}
\item[{The in-memory {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can be created manually in 3 steps:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
create the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} (specifying \sphinxcode{\sphinxupquote{parametric\_dim}} and \sphinxcode{\sphinxupquote{spatial\_dim}}),

\item {} 
add nodes,

\item {} 
add elements.

\end{enumerate}

\end{description}

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parametric\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the dimension of the topology of the
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} (e.g. a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} composed of squares would have a
parametric dimension of 2 and a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} composed of cubes
would have a parametric dimension of 3).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{spatial\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the number of coordinate dimensions
needed to describe the locations of the nodes making up the
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.  For a manifold the spatial dimension can be larger
than the parametric dimension (e.g. the 2D surface of a
sphere in 3D space), but it cannot be smaller.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} ({\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CoordSys}}}}}) \textendash{} Coordinate system for the
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_DEG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SPH\_DEG}}}}}.

\end{description}\end{quote}

\sphinxstylestrong{Created from file:}

Note that {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}} created from file do not use the \sphinxcode{\sphinxupquote{parametric\_dim}} and
\sphinxcode{\sphinxupquote{spatial\_dim}} parameters.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} the name of NetCDF file containing the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filetype}} ({\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{FileFormat}}}}}) \textendash{} the input
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{FileFormat}}}}} of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{convert\_to\_dual}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} a boolean value to specify if the
dual {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} should be calculated.  Defaults to False.  This
argument is only supported with
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{add\_user\_area}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} a boolean value to specify if an area
property should be added to the mesh.  This argument is only
supported for {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SCRIP}}}}}
or {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.ESMFMESH}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ESMFMESH}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to False.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{meshname}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} the name of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} metadata variable in
a UGRID file.  This argument is only supported with
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to the empty string.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mask\_flag}} ({\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{MeshLoc}}}}}) \textendash{} an enumerated integer that, if
specified, tells whether a mask in a UGRID file should be
defined on the \sphinxcode{\sphinxupquote{Mesh}}.
This argument is only supported with
{\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to no masking.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{varname}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} a variable name for the mask in a UGRID file
if mask\_flag is specified.  This argument is only supported
for {\hyperref[\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UGRID}}}}}.
If \sphinxcode{\sphinxupquote{None}}, defaults to the empty string.

\end{itemize}

\end{description}\end{quote}
\index{area (ESMF.api.mesh.Mesh attribute)@\spxentry{area}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.area}}\pysigline{\sphinxbfcode{\sphinxupquote{area}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A two element list of numpy arrays to hold values for the nodes
and elements of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\item[{Returns}] \leavevmode
The {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} area represented as a numpy
array of floats of the same number of entries as {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} elements.

\end{description}\end{quote}

\end{fulllineitems}

\index{coords (ESMF.api.mesh.Mesh attribute)@\spxentry{coords}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.coords}}\pysigline{\sphinxbfcode{\sphinxupquote{coords}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A two element list of numpy arrays to hold values for the nodes
and elements of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\item[{Returns}] \leavevmode
The coordinates represented as a numpy array of floats
with a value for each node and/or element of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{coord\_sys (ESMF.api.mesh.Mesh attribute)@\spxentry{coord\_sys}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.coord_sys}}\pysigline{\sphinxbfcode{\sphinxupquote{coord\_sys}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CoordSys}}}}}

\item[{Returns}] \leavevmode
The coordinate system of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{mask (ESMF.api.mesh.Mesh attribute)@\spxentry{mask}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.mask}}\pysigline{\sphinxbfcode{\sphinxupquote{mask}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A two element list of numpy arrays to hold values for the nodes
and elements of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\item[{Returns}] \leavevmode
The masked values on the nodes and elements of the
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{rank (ESMF.api.mesh.Mesh attribute)@\spxentry{rank}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.rank}}\pysigline{\sphinxbfcode{\sphinxupquote{rank}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The rank of the Mesh, (i.e. always 1).

\end{description}\end{quote}

\end{fulllineitems}

\index{size (ESMF.api.mesh.Mesh attribute)@\spxentry{size}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.size}}\pysigline{\sphinxbfcode{\sphinxupquote{size}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A two element list of integers.

\item[{Returns}] \leavevmode
The number of nodes and elements in the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} on the current
processor.

\end{description}\end{quote}

\end{fulllineitems}

\index{size\_owned (ESMF.api.mesh.Mesh attribute)@\spxentry{size\_owned}\spxextra{ESMF.api.mesh.Mesh attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.size_owned}}\pysigline{\sphinxbfcode{\sphinxupquote{size\_owned}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A two element list of integers.

\item[{Returns}] \leavevmode
The number of owned nodes and elements in the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} on the
current processor.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_elements() (ESMF.api.mesh.Mesh method)@\spxentry{add\_elements()}\spxextra{ESMF.api.mesh.Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.add_elements}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_elements}}}{\emph{element\_count}, \emph{element\_ids}, \emph{element\_types}, \emph{element\_conn}, \emph{element\_mask=None}, \emph{element\_area=None}, \emph{element\_coords=None}}{}
Add elements to a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, this must be done after adding nodes.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_count}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the number of elements to add to the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_ids}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of of shape
\sphinxcode{\sphinxupquote{(element\_count, 1)}} to specify the element ids.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_types}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of
\sphinxcode{\sphinxupquote{MeshElemType{}`s of shape
{}`{}`(element\_count, 1){}`}} to specify the element types.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_conn}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape
\sphinxcode{\sphinxupquote{sum(element\_types{[}:{]}, 1)}} to specify the connectivity of the
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}. The connectivity array is constructed by concatenating the
tuples that correspond to the element\_ids. The connectivity tuples
are constructed by listing the node\_ids of each element in
\sphinxstylestrong{COUNTERCLOCKWISE} order.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape
\sphinxcode{\sphinxupquote{(element\_count, 1)}} containing integer values to specify masked
elements. The specific values that are masked are specified in the
{\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} constructor.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_area}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape
\sphinxcode{\sphinxupquote{(element\_count, 1)}} to specify the areas of the elements.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element\_coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape
\sphinxcode{\sphinxupquote{(element\_count, 1)}} to specify the coordinates of the elements.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_nodes() (ESMF.api.mesh.Mesh method)@\spxentry{add\_nodes()}\spxextra{ESMF.api.mesh.Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.add_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodes}}}{\emph{node\_count}, \emph{node\_ids}, \emph{node\_coords}, \emph{node\_owners}}{}
Add nodes to a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, this must be done before adding elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node\_count}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the number of nodes to add to the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node\_ids}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape (node\_count, 1) to
specify the node\_ids.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node\_coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape
(spatial\_dim*node\_count, 1) to specify the coordinates of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.
The array should be constructed by concatenating the coordinate
tuples into a numpy array that correspond to node\_ids.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node\_owners}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of shape (node\_count, 1) to
specify the rank of the processor that owns each node.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (ESMF.api.mesh.Mesh method)@\spxentry{copy()}\spxextra{ESMF.api.mesh.Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} in an ESMF-safe manner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} shallow copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{destroy() (ESMF.api.mesh.Mesh method)@\spxentry{destroy()}\spxextra{ESMF.api.mesh.Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.destroy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{destroy}}}{}{}
Release the memory associated with a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{fulllineitems}

\index{free\_memory() (ESMF.api.mesh.Mesh method)@\spxentry{free\_memory()}\spxextra{ESMF.api.mesh.Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.free_memory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{free\_memory}}}{}{}
Free memory associated with the creation of a
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} which is no longer needed for ongoing
operations.

\end{fulllineitems}

\index{get\_coords() (ESMF.api.mesh.Mesh method)@\spxentry{get\_coords()}\spxextra{ESMF.api.mesh.Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:ESMF.api.mesh.Mesh.get_coords}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_coords}}}{\emph{coord\_dim}, \emph{meshloc=\textless{}MeshLoc.NODE: 0\textgreater{}}}{}
Return a numpy array of coordinates at a specified {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} 
location (coordinates can only be returned for the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
{\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc.NODE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NODE}}}}}s
at this time). The returned array is NOT a copy, it is
directly aliased to the underlying memory allocated by ESMF.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{coord\_dim}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} the dimension number of the coordinates to return:
e.g. \sphinxcode{\sphinxupquote{{[}x, y, z{]} = (0, 1, 2)}}, or \sphinxcode{\sphinxupquote{{[}lat, lon{]} = (0, 1)}}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{meshloc}} ({\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{MeshLoc}}}}}) \textendash{} the {\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshLoc}}}}} of the
coordinates.  If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc.NODE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NODE}}}}}.

\item[{Returns}] \leavevmode
A numpy array of coordinate values at the specified
{\hyperref[\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshLoc}}}}}.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{LocStream}
\label{\detokenize{locstream:locstream}}\label{\detokenize{locstream::doc}}\index{LocStream (class in ESMF.api.locstream)@\spxentry{LocStream}\spxextra{class in ESMF.api.locstream}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.locstream.}}\sphinxbfcode{\sphinxupquote{LocStream}}}{\emph{**kwargs}}{}
The {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} class is a Python wrapper object for the ESMF LocStream.
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} is a derived type of a Python dictionary.

The individual values of all key arrays are referenced to those of the
underlying Fortran ESMF object.

A {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} is used to represent the locations of a
set of data points. The values of the data points are stored within a
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} created using the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

In the data assimilation world, location streams can be thought of as a set
of observations. Their locations are generally described using Cartesian
\sphinxcode{\sphinxupquote{(x, y, z)}}, or \sphinxcode{\sphinxupquote{(lat, lon, height)}} coordinates. There is no assumption
of any regularity in the positions of the points. To make the concept more
general, the locations for each data point are represented using a construct
called keys. Keys can include other descriptors besides location, including
a second set of coordinates.

For more information about the ESMF LocStream class, please see the
\sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_7\_1\_0r/ESMF\_refdoc/node5.html\#SECTION05090000000000000000}{ESMF LocStream documentation}.

{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} follows standard dictionary syntax. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mask} \PYG{o}{=} \PYG{n}{locstream}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ESMF:Mask}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Setting keys of lists of mixed types can result in errors due to
type mismatches from the ESMF library.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Mask must be of type {\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind.I4}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{I4}}}}},
and coordinates must by of type {\hyperref[\detokenize{TypeKind:ESMF.api.constants.TypeKind.R8}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{R8}}}}}.
\end{sphinxadmonition}

For ESMF to be able to recognize coordinates specified in a {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} key
they need to be named with the appropriate identifiers. The particular
identifiers depend on the coordinate system (i.e. \sphinxcode{\sphinxupquote{coord\_sys}} argument)
used to create the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

The valid values are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Coordinate System
&\sphinxstyletheadfamily 
dimension 1
&\sphinxstyletheadfamily 
dimension 2
&\sphinxstyletheadfamily 
dimension 3
\\
\hline
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_DEG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SPH\_DEG}}}}}
&
ESMF:Lon
&
ESMF:Lat
&
ESMF:Radius
\\
\hline
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_RAD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SPH\_RAD}}}}}
&
ESMF:Lon
&
ESMF:Lat
&
ESMF:Radius
\\
\hline
{\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.CART}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CART}}}}}
&
ESMF:X
&
ESMF:Y
&
ESMF:Z
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{location\_count}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The number of points in this stream.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coord\_sys}} ({\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CoordSys}}}}}) \textendash{} Coordinate system for the location stream.
If \sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_DEG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SPH\_DEG}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Optional name for the location stream.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{esmf}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Internal parameter controlling shallow copying by ESMF.

\end{itemize}

\end{description}\end{quote}
\index{lower\_bounds (ESMF.api.locstream.LocStream attribute)@\spxentry{lower\_bounds}\spxextra{ESMF.api.locstream.LocStream attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.lower_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{lower\_bounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The lower bounds of the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{name (ESMF.api.locstream.LocStream attribute)@\spxentry{name}\spxextra{ESMF.api.locstream.LocStream attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#str}{str}

\item[{Returns}] \leavevmode
The name of the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{rank (ESMF.api.locstream.LocStream attribute)@\spxentry{rank}\spxextra{ESMF.api.locstream.LocStream attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.rank}}\pysigline{\sphinxbfcode{\sphinxupquote{rank}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The rank of the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{size (ESMF.api.locstream.LocStream attribute)@\spxentry{size}\spxextra{ESMF.api.locstream.LocStream attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.size}}\pysigline{\sphinxbfcode{\sphinxupquote{size}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The size of the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{upper\_bounds (ESMF.api.locstream.LocStream attribute)@\spxentry{upper\_bounds}\spxextra{ESMF.api.locstream.LocStream attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.upper_bounds}}\pysigline{\sphinxbfcode{\sphinxupquote{upper\_bounds}}}~\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{int}

\item[{Returns}] \leavevmode
The upper bounds of the {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (ESMF.api.locstream.LocStream method)@\spxentry{copy()}\spxextra{ESMF.api.locstream.LocStream method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy a {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} in an ESMF-safe manner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}} shallow copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{destroy() (ESMF.api.locstream.LocStream method)@\spxentry{destroy()}\spxextra{ESMF.api.locstream.LocStream method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{locstream:ESMF.api.locstream.LocStream.destroy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{destroy}}}{}{}
Release the memory associated with a
{\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Regrid}
\label{\detokenize{regrid:regrid}}\label{\detokenize{regrid::doc}}\index{Regrid (class in ESMF.api.regrid)@\spxentry{Regrid}\spxextra{class in ESMF.api.regrid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regrid:ESMF.api.regrid.Regrid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.regrid.}}\sphinxbfcode{\sphinxupquote{Regrid}}}{\emph{**kwargs}}{}
The {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} object represents a regridding operator between two {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}}.  The
creation of this object is analogous to ESMF\_FieldRegridStore(), and
calling this object corresponds to ESMF\_FieldRegrid().
ESMF\_FieldRegridRelease() is called when the {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} object goes out of
scope (this only happens when the {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}} goes out of scope, there is a
destroy() call for explicit deallocation of the {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}).

For more information about the ESMF Regridding functionality, please see
the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_7\_1\_0r/ESMF\_refdoc/node5.html\#SECTION05012000000000000000}{ESMF Regrid documentation}.

The following arguments are used to create a handle to a Regridding
operation between two {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}}.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{srcfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} source {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} associated with an underlying {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}},
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dstfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} destination {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} associated with an underlying
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.  The data in this {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} may be overwritten
by this call.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} path to the output netCDF weight file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rh\_filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} path to the output RouteHandle file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{src\_mask\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of values that should be
considered masked value on the source {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dst\_mask\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} a numpy array of values that should be
considered masked value on the destination {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{regrid\_method}} ({\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{RegridMethod}}}}}) \textendash{} specifies which
{\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridMethod}}}}} to use.  If \sphinxcode{\sphinxupquote{None}}, defaults
to {\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.BILINEAR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BILINEAR}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pole\_method}} ({\hyperref[\detokenize{PoleMethod:ESMF.api.constants.PoleMethod}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{PoleMethod}}}}}) \textendash{} specifies which type of artificial pole
to construct on the source {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} for regridding.  If
\sphinxcode{\sphinxupquote{None}}, defaults to: {\hyperref[\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.NONE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NONE}}}}} for
regridmethod == {\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE}}}}}, or
{\hyperref[\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.ALLAVG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ALLAVG}}}}} for
regridmethod != {\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{regrid\_pole\_npoints}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} specifies how many points to average over
if polemethod == {\hyperref[\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.ALLAVG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ALLAVG}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{line\_type}} ({\hyperref[\detokenize{LineType:ESMF.api.constants.LineType}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LineType}}}}}) \textendash{} select the path of the line that connects two
points on the surface of a sphere.  This in turn controls the path along
which distances are calculated and the shape of the edges that make up a
cell.  If \sphinxcode{\sphinxupquote{None}}, defaults to:
{\hyperref[\detokenize{LineType:ESMF.api.constants.LineType.GREAT_CIRCLE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GREAT\_CIRCLE}}}}} for
regridmethod == {\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE}}}}}, or
{\hyperref[\detokenize{LineType:ESMF.api.constants.LineType.CART}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CART}}}}} for
regridmethod != {\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{norm\_type}} ({\hyperref[\detokenize{NormType:ESMF.api.constants.NormType}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{NormType}}}}}) \textendash{} control which type of normalization to do when
generating conservative regridding weights. If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{NormType:ESMF.api.constants.NormType.DSTAREA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DSTAREA}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{extrap\_method}} ({\hyperref[\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ExtrapMethod}}}}}) \textendash{} Specify which extrapolation method to use on 
unmapped destination points after regridding.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{extrap\_num\_src\_pnts}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The number of source points to use for the 
extrapolation methods that use more than one source point 
(e.g. {\hyperref[\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod.NEAREST_IDAVG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NEAREST\_IDAVG}}}}}). If not 
specified, defaults to 8.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{extrap\_dist\_exponent}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The exponent to raise the distance to when 
calculating weights for the {\hyperref[\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod.NEAREST_IDAVG}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NEAREST\_IDAVG}}}}}
extrapolation method. A higher value reduces the influence of more distant
points. If not specified, defaults to \sphinxcode{\sphinxupquote{2.0}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{unmapped\_action}} ({\hyperref[\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{UnmappedAction}}}}}) \textendash{} specifies which action to take if a
destination point is found which does not map to any source point. If
\sphinxcode{\sphinxupquote{None}}, defaults to {\hyperref[\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction.ERROR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ERROR}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_degenerate}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} Ignore degenerate cells when checking the
input {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grids}}}}} or {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Meshes}}}}}
for errors. If this is set to True, then the regridding proceeds, but
degenerate cells will be skipped. If set to False, a degenerate cell produces
an error. This currently only applies to {\hyperref[\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CONSERVE}}}}},
other regrid methods currently always skip degenerate cells. If \sphinxcode{\sphinxupquote{None}}, defaults
to \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{src\_frac\_field}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} return a numpy array of values containing
weights corresponding to the amount of each {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
value which contributes to the total mass of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dst\_frac\_field}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} return a numpy array of values containing
weights corresponding to the amount of each {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
value which contributes to the total mass of the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{factors}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} If \sphinxcode{\sphinxupquote{True}}, return the factor and factor index list
when calling into \sphinxcode{\sphinxupquote{ESMF}}’s regrid store method. These lists are converted
to NumPy arrays and attached to the regrid object. The factor arrays
are retrievable via \sphinxcode{\sphinxupquote{get\_factors()}} or \sphinxcode{\sphinxupquote{get\_weights\_dict()}}.
See the respective documentation on those methods for additional information.
For more information on how \sphinxcode{\sphinxupquote{ESMF}} treats factor retrieval see the
documentation for \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION050366000000000000000}{ESMF\_FieldRegridStore}.

\end{itemize}

\end{description}\end{quote}
\index{\_\_call\_\_() (ESMF.api.regrid.Regrid method)@\spxentry{\_\_call\_\_()}\spxextra{ESMF.api.regrid.Regrid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regrid:ESMF.api.regrid.Regrid.__call__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{\emph{srcfield}, \emph{dstfield}, \emph{zero\_region=None}}{}
Call a regridding operation from srcfield to dstfield.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{srcfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} of source data to regrid.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dstfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} to hold the regridded data.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{zero\_region}} ({\hyperref[\detokenize{Region:ESMF.api.constants.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} specify which region of the field indices
will be zeroed out before adding the values resulting from the
interpolation.  If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{Region:ESMF.api.constants.Region.TOTAL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TOTAL}}}}}.

\item[{Returns}] \leavevmode
dstfield

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (ESMF.api.regrid.Regrid method)@\spxentry{copy()}\spxextra{ESMF.api.regrid.Regrid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regrid:ESMF.api.regrid.Regrid.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy a {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} in an ESMF-safe manner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} shallow copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{destroy() (ESMF.api.regrid.Regrid method)@\spxentry{destroy()}\spxextra{ESMF.api.regrid.Regrid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regrid:ESMF.api.regrid.Regrid.destroy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{destroy}}}{}{}
Release the memory associated with a {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}.

\end{fulllineitems}

\index{get\_factors() (ESMF.api.regrid.Regrid method)@\spxentry{get\_factors()}\spxextra{ESMF.api.regrid.Regrid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regrid:ESMF.api.regrid.Regrid.get_factors}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_factors}}}{\emph{deep\_copy=False}}{}
Return factor and factor index arrays. These arrays will only be
available if the \sphinxcode{\sphinxupquote{Regrid}} object was initialized with \sphinxcode{\sphinxupquote{factors=True}}.
See the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_8\_0\_1/ESMF\_refdoc/node5.html\#SECTION050366000000000000000}{ESMF documentation}
for additional information on these arrays (see below for indexing in
Python though).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{factors}\PYG{p}{,} \PYG{n}{factors\PYGZus{}index} \PYG{o}{=} \PYG{n}{get\PYGZus{}factors}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}

The first tuple element \sphinxcode{\sphinxupquote{factors}} will have shape \sphinxcode{\sphinxupquote{(m,)}} where
\sphinxcode{\sphinxupquote{m}} is the number of factors or weights. It will be \sphinxcode{\sphinxupquote{dtype(float64)}}.
The second tupe element \sphinxcode{\sphinxupquote{factors\_index}} will have shape \sphinxcode{\sphinxupquote{(m, 2)}}
where \sphinxcode{\sphinxupquote{m}} is the number of factors or weights. The source/col indices
are selected by \sphinxcode{\sphinxupquote{factors\_index{[}:, 0{]}}}. The destination/row indices
are selected by \sphinxcode{\sphinxupquote{factors\_index{[}:, 1{]}}}. It will be \sphinxcode{\sphinxupquote{dtype(int32)}}.

\begin{sphinxadmonition}{note}{Note:}
If \sphinxcode{\sphinxupquote{deep\_copy=True}}, array memory is C contiguous according
to NumPy array flags (\sphinxcode{\sphinxupquote{\textless{}array\textgreater{}.flags}}).
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
Remember to call \sphinxcode{\sphinxupquote{destroy()}} to deallocate
memory associated with a regrid operation. This will be called by
the Python garbage collector. However, if numerous regridding operations
are called in a tight loop, a memory leak will occur without a call
to \sphinxcode{\sphinxupquote{destroy}}.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{deep\_copy}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} If \sphinxcode{\sphinxupquote{True}}, make deep copies of the returned
arrays. If \sphinxcode{\sphinxupquote{False}} (the default), the returned arrays will reference
the underlying \sphinxcode{\sphinxupquote{ESMF}} memory.

\item[{Returns}] \leavevmode
tuple of NumPy array objects

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_weights\_dict() (ESMF.api.regrid.Regrid method)@\spxentry{get\_weights\_dict()}\spxextra{ESMF.api.regrid.Regrid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regrid:ESMF.api.regrid.Regrid.get_weights_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_weights\_dict}}}{\emph{deep\_copy=False}}{}
Return a dictionary mapping that is more user-friendly for weight/factor
retrieval. Please read the documentation for \sphinxcode{\sphinxupquote{get\_factors()}}
before using this function.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Key
&\sphinxstyletheadfamily 
Value
\\
\hline
\sphinxcode{\sphinxupquote{weights}}
&
Weight value array
\\
\hline
\sphinxcode{\sphinxupquote{row\_dst}}
&
Destination/row indices
\\
\hline
\sphinxcode{\sphinxupquote{col\_src}}
&
Source/col indices
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
If \sphinxcode{\sphinxupquote{deep\_copy=True}}, array memory is C contiguous according
to NumPy array flags (\sphinxcode{\sphinxupquote{\textless{}array\textgreater{}.flags}}).
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{deep\_copy}} (\sphinxhref{https://docs.python.org/2.7/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}) \textendash{} If \sphinxcode{\sphinxupquote{True}}, make deep copies of the returned
arrays. If \sphinxcode{\sphinxupquote{False}} (the default), the returned arrays will reference
the underlying \sphinxcode{\sphinxupquote{ESMF}} memory.

\item[{Returns}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{RegridFromFile}
\label{\detokenize{regridfromfile:regridfromfile}}\label{\detokenize{regridfromfile::doc}}\index{RegridFromFile (class in ESMF.api.regrid)@\spxentry{RegridFromFile}\spxextra{class in ESMF.api.regrid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.regrid.}}\sphinxbfcode{\sphinxupquote{RegridFromFile}}}{\emph{**kwargs}}{}
The {\hyperref[\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridFromFile}}}}} object represents a regridding
operator between two {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} that is read
from a file. The creation of this object is analogous to= ESMF\_FieldSMMStore(),
and calling this object corresponds to ESMF\_FieldRegrid(). ESMF\_FieldRegridRelease()
is called when the {\hyperref[\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridFromFile}}}}} object goes
out of scope (this only happens when the {\hyperref[\detokenize{manager:ESMF.api.esmpymanager.Manager}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Manager}}}}}
goes out of scope, there is a destroy() call for explicit deallocation of
the {\hyperref[\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridFromFile}}}}}).

For more information about the ESMF Regridding functionality, please see
the \sphinxhref{http://www.earthsystemmodeling.org/esmf\_releases/public/ESMF\_7\_1\_0r/ESMF\_refdoc/node5.html\#SECTION05012000000000000000}{ESMF Regrid documentation}.

The following arguments are used to create a handle to a regridding
operation between two {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}}.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{srcfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} source {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} associated
with an underlying {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dstfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} destination {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} associated
with an underlying {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}, {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
or {\hyperref[\detokenize{locstream:ESMF.api.locstream.LocStream}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LocStream}}}}}.  The data in this {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
may be overwritten by this call.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the name of the file from which to retrieve the
weights.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rh\_filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the name of the file from which to retrieve the
routehandle information.

\end{itemize}

\end{description}\end{quote}
\index{\_\_call\_\_() (ESMF.api.regrid.RegridFromFile method)@\spxentry{\_\_call\_\_()}\spxextra{ESMF.api.regrid.RegridFromFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile.__call__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{\emph{srcfield}, \emph{dstfield}, \emph{zero\_region=None}}{}
Call a regridding operation from srcfield to dstfield.

\sphinxstyleemphasis{REQUIRED:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{srcfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} of source data to regrid.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dstfield}} ({\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Field}}}}}) \textendash{} the {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} to hold the regridded data.

\end{itemize}

\end{description}\end{quote}

\sphinxstyleemphasis{OPTIONAL:}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{zero\_region}} ({\hyperref[\detokenize{Region:ESMF.api.constants.Region}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Region}}}}}) \textendash{} specify which region of the field indices
will be zeroed out before adding the values resulting from the
interpolation.  If \sphinxcode{\sphinxupquote{None}}, defaults to
{\hyperref[\detokenize{Region:ESMF.api.constants.Region.TOTAL}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TOTAL}}}}}.

\item[{Returns}] \leavevmode
dstfield

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (ESMF.api.regrid.RegridFromFile method)@\spxentry{copy()}\spxextra{ESMF.api.regrid.RegridFromFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{}
Copy a {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} in an ESMF-safe manner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}} shallow copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{destroy() (ESMF.api.regrid.RegridFromFile method)@\spxentry{destroy()}\spxextra{ESMF.api.regrid.RegridFromFile method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile.destroy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{destroy}}}{}{}
Release the memory associated with the {\hyperref[\detokenize{regridfromfile:ESMF.api.regrid.RegridFromFile}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RegridFromFile}}}}}
object.

\end{fulllineitems}


\end{fulllineitems}



\section{Named Constants}
\label{\detokenize{appendix:named-constants}}

\subsection{CoordSys}
\label{\detokenize{CoordSys:coordsys}}\label{\detokenize{CoordSys::doc}}\index{CoordSys (class in ESMF.api.constants)@\spxentry{CoordSys}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{CoordSys:ESMF.api.constants.CoordSys}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{CoordSys}}}
This flag indicates the coordinate system of a {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}. This value is
useful both to indicate to other users the type of the coordinates,
but also to control how the coordinates are interpreted in
regridding methods (e.g. {\hyperref[\detokenize{regrid:ESMF.api.regrid.Regrid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Regrid}}}}}).
\index{CART (ESMF.api.constants.CoordSys attribute)@\spxentry{CART}\spxextra{ESMF.api.constants.CoordSys attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{CoordSys:ESMF.api.constants.CoordSys.CART}}\pysigline{\sphinxbfcode{\sphinxupquote{CART}}\sphinxbfcode{\sphinxupquote{ = \textless{}CoordSys.CART: 0\textgreater{}}}}
Cartesian coordinate system. In this system, the Cartesian
coordinates are mapped to the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} coordinate dimensions in the
following order: x, y, z. (e.g. using coord\_dim=1 in
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid.get_coords}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_coords()}}}}} references the y dimension)

\end{fulllineitems}

\index{SPH\_DEG (ESMF.api.constants.CoordSys attribute)@\spxentry{SPH\_DEG}\spxextra{ESMF.api.constants.CoordSys attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_DEG}}\pysigline{\sphinxbfcode{\sphinxupquote{SPH\_DEG}}\sphinxbfcode{\sphinxupquote{ = \textless{}CoordSys.SPH\_DEG: 1\textgreater{}}}}
Spherical coordinates in degrees. In this system, the spherical
coordinates are mapped to the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} coordinate dimensions in the
following order: longitude, latitude, radius. (E.g. using
coord\_dim=1 in \sphinxcode{\sphinxupquote{get\_coords(){}`}} references the latitude dimension).

\end{fulllineitems}

\index{SPH\_RAD (ESMF.api.constants.CoordSys attribute)@\spxentry{SPH\_RAD}\spxextra{ESMF.api.constants.CoordSys attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{CoordSys:ESMF.api.constants.CoordSys.SPH_RAD}}\pysigline{\sphinxbfcode{\sphinxupquote{SPH\_RAD}}\sphinxbfcode{\sphinxupquote{ = \textless{}CoordSys.SPH\_RAD: 2\textgreater{}}}}
Spherical coordinates in radians. In this system, the spherical
coordinates are mapped to the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} coordinate dimensions in the
following order: longitude, latitude, radius. (E.g. using
coord\_dim=1 in {\hyperref[\detokenize{grid:ESMF.api.grid.Grid.get_coords}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_coords()}}}}} references the latitude dimension).

\end{fulllineitems}


\end{fulllineitems}



\subsection{ExtrapMethod}
\label{\detokenize{ExtrapMethod:extrapmethod}}\label{\detokenize{ExtrapMethod::doc}}\index{ExtrapMethod (class in ESMF.api.constants)@\spxentry{ExtrapMethod}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{ExtrapMethod}}}
Specify which extrapolation method to use on unmapped destination points after 
regridding.
\index{NONE (ESMF.api.constants.ExtrapMethod attribute)@\spxentry{NONE}\spxextra{ESMF.api.constants.ExtrapMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod.NONE}}\pysigline{\sphinxbfcode{\sphinxupquote{NONE}}\sphinxbfcode{\sphinxupquote{ = \textless{}ExtrapMethod.NONE: 0\textgreater{}}}}
Indicates that no extrapolation should be done.

\end{fulllineitems}

\index{NEAREST\_STOD (ESMF.api.constants.ExtrapMethod attribute)@\spxentry{NEAREST\_STOD}\spxextra{ESMF.api.constants.ExtrapMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod.NEAREST_STOD}}\pysigline{\sphinxbfcode{\sphinxupquote{NEAREST\_STOD}}\sphinxbfcode{\sphinxupquote{ = \textless{}ExtrapMethod.NEAREST\_STOD: 1\textgreater{}}}}
Inverse distance weighted average. 
Here the value of a destination point is the weighted average of the 
closest N source points. The weight is the reciprocal of the distance of 
the source point from the destination point raised to a power P. All the
weights contributing to one destination point are normalized so that they 
sum to 1.0. The user can choose N and P when using this method, but 
defaults are also provided.

\end{fulllineitems}

\index{NEAREST\_IDAVG (ESMF.api.constants.ExtrapMethod attribute)@\spxentry{NEAREST\_IDAVG}\spxextra{ESMF.api.constants.ExtrapMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ExtrapMethod:ESMF.api.constants.ExtrapMethod.NEAREST_IDAVG}}\pysigline{\sphinxbfcode{\sphinxupquote{NEAREST\_IDAVG}}\sphinxbfcode{\sphinxupquote{ = \textless{}ExtrapMethod.NEAREST\_IDAVG: 2\textgreater{}}}}
Nearest source to destination. 
Here each destination point is mapped to the closest source point. A given 
source point may go to multiple destination points, but no destination 
point will receive input from more than one source point.

\end{fulllineitems}


\end{fulllineitems}



\subsection{FileFormat}
\label{\detokenize{FileFormat:fileformat}}\label{\detokenize{FileFormat::doc}}\index{FileFormat (class in ESMF.api.constants)@\spxentry{FileFormat}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{FileFormat}}}
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} and {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} objects 
may be created from specifications in a NetCDF data file.  This flag 
indicates the format of the data file.
\index{VTK (ESMF.api.constants.FileFormat attribute)@\spxentry{VTK}\spxextra{ESMF.api.constants.FileFormat attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat.VTK}}\pysigline{\sphinxbfcode{\sphinxupquote{VTK}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileFormat.VTK: 1\textgreater{}}}}
Use the VTK file format.

\end{fulllineitems}

\index{SCRIP (ESMF.api.constants.FileFormat attribute)@\spxentry{SCRIP}\spxextra{ESMF.api.constants.FileFormat attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat.SCRIP}}\pysigline{\sphinxbfcode{\sphinxupquote{SCRIP}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileFormat.SCRIP: 2\textgreater{}}}}
Use the {\hyperref[\detokenize{api:id2}]{\sphinxcrossref{\DUrole{std,std-ref}{SCRIP}}}} file format.

\end{fulllineitems}

\index{ESMFMESH (ESMF.api.constants.FileFormat attribute)@\spxentry{ESMFMESH}\spxextra{ESMF.api.constants.FileFormat attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat.ESMFMESH}}\pysigline{\sphinxbfcode{\sphinxupquote{ESMFMESH}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileFormat.ESMFMESH: 3\textgreater{}}}}
Use the {\hyperref[\detokenize{api:id4}]{\sphinxcrossref{\DUrole{std,std-ref}{ESMFMESH}}}} unstructured grid file format.

\end{fulllineitems}

\index{ESMFGRID (ESMF.api.constants.FileFormat attribute)@\spxentry{ESMFGRID}\spxextra{ESMF.api.constants.FileFormat attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat.ESMFGRID}}\pysigline{\sphinxbfcode{\sphinxupquote{ESMFGRID}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileFormat.ESMFGRID: 4\textgreater{}}}}
Use the ESMF structured grid file format.

\end{fulllineitems}

\index{UGRID (ESMF.api.constants.FileFormat attribute)@\spxentry{UGRID}\spxextra{ESMF.api.constants.FileFormat attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat.UGRID}}\pysigline{\sphinxbfcode{\sphinxupquote{UGRID}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileFormat.UGRID: 5\textgreater{}}}}
Use the {\hyperref[\detokenize{api:id6}]{\sphinxcrossref{\DUrole{std,std-ref}{UGRID}}}} unstructured grid file format.

\end{fulllineitems}

\index{GRIDSPEC (ESMF.api.constants.FileFormat attribute)@\spxentry{GRIDSPEC}\spxextra{ESMF.api.constants.FileFormat attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileFormat:ESMF.api.constants.FileFormat.GRIDSPEC}}\pysigline{\sphinxbfcode{\sphinxupquote{GRIDSPEC}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileFormat.GRIDSPEC: 6\textgreater{}}}}
Use the {\hyperref[\detokenize{api:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{UGRID single tile grid file format based on CF V1.6 conventions (a.k.a GRIDSPEC)}}}}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{FileMode}
\label{\detokenize{FileMode:filemode}}\label{\detokenize{FileMode::doc}}\index{FileMode (class in ESMF.api.constants)@\spxentry{FileMode}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileMode:ESMF.api.constants.FileMode}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{FileMode}}}
Specify which mode to use when writing a weight file.
\index{BASIC (ESMF.api.constants.FileMode attribute)@\spxentry{BASIC}\spxextra{ESMF.api.constants.FileMode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileMode:ESMF.api.constants.FileMode.BASIC}}\pysigline{\sphinxbfcode{\sphinxupquote{BASIC}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileMode.BASIC: 0\textgreater{}}}}
Indicates that only the factorList and factorIndexList should be written.

\end{fulllineitems}

\index{WITHAUX (ESMF.api.constants.FileMode attribute)@\spxentry{WITHAUX}\spxextra{ESMF.api.constants.FileMode attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{FileMode:ESMF.api.constants.FileMode.WITHAUX}}\pysigline{\sphinxbfcode{\sphinxupquote{WITHAUX}}\sphinxbfcode{\sphinxupquote{ = \textless{}FileMode.WITHAUX: 1\textgreater{}}}}
Indicates that grid center coordinates should also be written.

\end{fulllineitems}


\end{fulllineitems}



\subsection{GridItem}
\label{\detokenize{GridItem:griditem}}\label{\detokenize{GridItem::doc}}\index{GridItem (class in ESMF.api.constants)@\spxentry{GridItem}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridItem:ESMF.api.constants.GridItem}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{GridItem}}}
The {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} can contain other kinds of data besides coordinates. This
data is referred to as {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} “items”. Some items may be used
for calculations involving the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.
\index{MASK (ESMF.api.constants.GridItem attribute)@\spxentry{MASK}\spxextra{ESMF.api.constants.GridItem attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridItem:ESMF.api.constants.GridItem.MASK}}\pysigline{\sphinxbfcode{\sphinxupquote{MASK}}\sphinxbfcode{\sphinxupquote{ = \textless{}GridItem.MASK: 0\textgreater{}}}}
A grid item to represent a mask.

\end{fulllineitems}

\index{AREA (ESMF.api.constants.GridItem attribute)@\spxentry{AREA}\spxextra{ESMF.api.constants.GridItem attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GridItem:ESMF.api.constants.GridItem.AREA}}\pysigline{\sphinxbfcode{\sphinxupquote{AREA}}\sphinxbfcode{\sphinxupquote{ = \textless{}GridItem.AREA: 1\textgreater{}}}}
A grid item to represent an area field for conservative regridding.

\end{fulllineitems}


\end{fulllineitems}



\subsection{LineType}
\label{\detokenize{LineType:linetype}}\label{\detokenize{LineType::doc}}\index{LineType (class in ESMF.api.constants)@\spxentry{LineType}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{LineType:ESMF.api.constants.LineType}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{LineType}}}
This argument controls the path of the line which connects two points on
the surface of the sphere. This in turn controls the path along which
distances are calculated and the shape of the edges that make up a cell.
Both of these quantities can influence how interpolation weights are
calculated. As would be expected, this argument is only applicable with
grids which lie on the surface of a sphere.
\index{CART (ESMF.api.constants.LineType attribute)@\spxentry{CART}\spxextra{ESMF.api.constants.LineType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{LineType:ESMF.api.constants.LineType.CART}}\pysigline{\sphinxbfcode{\sphinxupquote{CART}}\sphinxbfcode{\sphinxupquote{ = \textless{}LineType.CART: 0\textgreater{}}}}
Cartesian line. When this option is specified distances are calculated in a
straight line through the 3D Cartesian space in which the sphere is
embedded. Cells are approximated by 3D planes bounded by 3D Cartesian lines
between their corner vertices. When calculating regrid weights, this line
type is currently the default for the following all regrid methods except
for conservative.

\end{fulllineitems}

\index{GREAT\_CIRCLE (ESMF.api.constants.LineType attribute)@\spxentry{GREAT\_CIRCLE}\spxextra{ESMF.api.constants.LineType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{LineType:ESMF.api.constants.LineType.GREAT_CIRCLE}}\pysigline{\sphinxbfcode{\sphinxupquote{GREAT\_CIRCLE}}\sphinxbfcode{\sphinxupquote{ = \textless{}LineType.GREAT\_CIRCLE: 1\textgreater{}}}}
Great circle line. When this option is specified distances are calculated
along a great circle path (the shortest distance between two points on a
sphere surface). Cells are bounded by great circle paths between their
corner vertices. When calculating regrid weights, this line type is
currently the default for the conservative regrid method.

\end{fulllineitems}


\end{fulllineitems}



\subsection{LogKind}
\label{\detokenize{LogKind:logkind}}\label{\detokenize{LogKind::doc}}\index{LogKind (class in ESMF.api.constants)@\spxentry{LogKind}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{LogKind:ESMF.api.constants.LogKind}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{LogKind}}}
This flag is used to specify how much logging should be done.
\index{MULTI (ESMF.api.constants.LogKind attribute)@\spxentry{MULTI}\spxextra{ESMF.api.constants.LogKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{LogKind:ESMF.api.constants.LogKind.MULTI}}\pysigline{\sphinxbfcode{\sphinxupquote{MULTI}}\sphinxbfcode{\sphinxupquote{ = \textless{}LogKind.MULTI: 2\textgreater{}}}}
Use multiple log files \textendash{} one per PET.

\end{fulllineitems}

\index{NONE (ESMF.api.constants.LogKind attribute)@\spxentry{NONE}\spxextra{ESMF.api.constants.LogKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{LogKind:ESMF.api.constants.LogKind.NONE}}\pysigline{\sphinxbfcode{\sphinxupquote{NONE}}\sphinxbfcode{\sphinxupquote{ = \textless{}LogKind.NONE: 3\textgreater{}}}}
Do not issue messages to a log file.

\end{fulllineitems}


\end{fulllineitems}



\subsection{MeshElemType}
\label{\detokenize{MeshElemType:meshelemtype}}\label{\detokenize{MeshElemType::doc}}\index{MeshElemType (class in ESMF.api.constants)@\spxentry{MeshElemType}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshElemType:ESMF.api.constants.MeshElemType}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{MeshElemType}}}
A {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} can be constructed from a combination of different elements.
The type of elements that can be used in a {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} depends on the
parametric dimension of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}, which is set during {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}
creation. The following are the valid {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} element types for each
valid {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} parametric dimension (2D or 3D).
\index{TRI (ESMF.api.constants.MeshElemType attribute)@\spxentry{TRI}\spxextra{ESMF.api.constants.MeshElemType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshElemType:ESMF.api.constants.MeshElemType.TRI}}\pysigline{\sphinxbfcode{\sphinxupquote{TRI}}\sphinxbfcode{\sphinxupquote{ = \textless{}MeshElemType.TRI: 3\textgreater{}}}}
2D triangular elements with 3 sides.

\end{fulllineitems}

\index{QUAD (ESMF.api.constants.MeshElemType attribute)@\spxentry{QUAD}\spxextra{ESMF.api.constants.MeshElemType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshElemType:ESMF.api.constants.MeshElemType.QUAD}}\pysigline{\sphinxbfcode{\sphinxupquote{QUAD}}\sphinxbfcode{\sphinxupquote{ = \textless{}MeshElemType.QUAD: 4\textgreater{}}}}
2D quadrilateral elements with 4 sides.

\end{fulllineitems}

\index{TETRA (ESMF.api.constants.MeshElemType attribute)@\spxentry{TETRA}\spxextra{ESMF.api.constants.MeshElemType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshElemType:ESMF.api.constants.MeshElemType.TETRA}}\pysigline{\sphinxbfcode{\sphinxupquote{TETRA}}\sphinxbfcode{\sphinxupquote{ = \textless{}MeshElemType.TETRA: 10\textgreater{}}}}
3D tetrahedral elements with 4 faces.

\end{fulllineitems}

\index{HEX (ESMF.api.constants.MeshElemType attribute)@\spxentry{HEX}\spxextra{ESMF.api.constants.MeshElemType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshElemType:ESMF.api.constants.MeshElemType.HEX}}\pysigline{\sphinxbfcode{\sphinxupquote{HEX}}\sphinxbfcode{\sphinxupquote{ = \textless{}MeshElemType.HEX: 12\textgreater{}}}}
3D hexahedral elements with 6 faces.

\end{fulllineitems}


\end{fulllineitems}



\subsection{MeshLoc}
\label{\detokenize{MeshLoc:meshloc}}\label{\detokenize{MeshLoc::doc}}\index{MeshLoc (class in ESMF.api.constants)@\spxentry{MeshLoc}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshLoc:ESMF.api.constants.MeshLoc}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{MeshLoc}}}
The {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} location used to hold {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} data.
\index{NODE (ESMF.api.constants.MeshLoc attribute)@\spxentry{NODE}\spxextra{ESMF.api.constants.MeshLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshLoc:ESMF.api.constants.MeshLoc.NODE}}\pysigline{\sphinxbfcode{\sphinxupquote{NODE}}\sphinxbfcode{\sphinxupquote{ = \textless{}MeshLoc.NODE: 0\textgreater{}}}}
The nodes of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{fulllineitems}

\index{ELEMENT (ESMF.api.constants.MeshLoc attribute)@\spxentry{ELEMENT}\spxextra{ESMF.api.constants.MeshLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MeshLoc:ESMF.api.constants.MeshLoc.ELEMENT}}\pysigline{\sphinxbfcode{\sphinxupquote{ELEMENT}}\sphinxbfcode{\sphinxupquote{ = \textless{}MeshLoc.ELEMENT: 1\textgreater{}}}}
The elements of the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{NormType}
\label{\detokenize{NormType:normtype}}\label{\detokenize{NormType::doc}}\index{NormType (class in ESMF.api.constants)@\spxentry{NormType}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{NormType:ESMF.api.constants.NormType}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{NormType}}}
When doing conservative regridding, this option allows the user
to select the type of normalization used when producing the weights.
\index{DSTAREA (ESMF.api.constants.NormType attribute)@\spxentry{DSTAREA}\spxextra{ESMF.api.constants.NormType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{NormType:ESMF.api.constants.NormType.DSTAREA}}\pysigline{\sphinxbfcode{\sphinxupquote{DSTAREA}}\sphinxbfcode{\sphinxupquote{ = \textless{}NormType.DSTAREA: 0\textgreater{}}}}
Destination area normalization. Here the weights are calculated by dividing
the area of overlap of the source and destination cells by the area of the
entire destination cell. In other words, the weight is the fraction of the
entire destination cell which overlaps with the given source cell.

\end{fulllineitems}

\index{FRACAREA (ESMF.api.constants.NormType attribute)@\spxentry{FRACAREA}\spxextra{ESMF.api.constants.NormType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{NormType:ESMF.api.constants.NormType.FRACAREA}}\pysigline{\sphinxbfcode{\sphinxupquote{FRACAREA}}\sphinxbfcode{\sphinxupquote{ = \textless{}NormType.FRACAREA: 1\textgreater{}}}}
Fraction area normalization. Here in addition to the weight calculation
done for destination area normalization the weights are also divided by the
fraction that the destination cell overlaps with the entire source grid. In
other words, the weight is the fraction of just the part of the destination
cell that overlaps with the entire source mesh.

\end{fulllineitems}


\end{fulllineitems}



\subsection{PoleKind}
\label{\detokenize{PoleKind:polekind}}\label{\detokenize{PoleKind::doc}}\index{PoleKind (class in ESMF.api.constants)@\spxentry{PoleKind}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleKind:ESMF.api.constants.PoleKind}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{PoleKind}}}
This type describes the type of connection that occurs at the pole of a  
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.
\index{NONE (ESMF.api.constants.PoleKind attribute)@\spxentry{NONE}\spxextra{ESMF.api.constants.PoleKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleKind:ESMF.api.constants.PoleKind.NONE}}\pysigline{\sphinxbfcode{\sphinxupquote{NONE}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleKind.NONE: 0\textgreater{}}}}
No connection at pole.

\end{fulllineitems}

\index{MONOPOLE (ESMF.api.constants.PoleKind attribute)@\spxentry{MONOPOLE}\spxextra{ESMF.api.constants.PoleKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleKind:ESMF.api.constants.PoleKind.MONOPOLE}}\pysigline{\sphinxbfcode{\sphinxupquote{MONOPOLE}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleKind.MONOPOLE: 1\textgreater{}}}}
This edge is connected to itself. Given that the edge is n elements long, 
then element i is connected to element i+n/2.

\end{fulllineitems}

\index{BIPOLE (ESMF.api.constants.PoleKind attribute)@\spxentry{BIPOLE}\spxextra{ESMF.api.constants.PoleKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleKind:ESMF.api.constants.PoleKind.BIPOLE}}\pysigline{\sphinxbfcode{\sphinxupquote{BIPOLE}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleKind.BIPOLE: 2\textgreater{}}}}
This edge is connected to itself. Given that the edge is n elements long, element i is connected to element n-i-1.

\end{fulllineitems}


\end{fulllineitems}



\subsection{PoleMethod}
\label{\detokenize{PoleMethod:polemethod}}\label{\detokenize{PoleMethod::doc}}\index{PoleMethod (class in ESMF.api.constants)@\spxentry{PoleMethod}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleMethod:ESMF.api.constants.PoleMethod}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{PoleMethod}}}
Indicates which type of artificial pole to construct on the source
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} for regridding.
\index{NONE (ESMF.api.constants.PoleMethod attribute)@\spxentry{NONE}\spxextra{ESMF.api.constants.PoleMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.NONE}}\pysigline{\sphinxbfcode{\sphinxupquote{NONE}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleMethod.NONE: 0\textgreater{}}}}
No pole. Destination points which lie above the top or below the bottom row
of the source {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} won’t be mapped.

\end{fulllineitems}

\index{ALLAVG (ESMF.api.constants.PoleMethod attribute)@\spxentry{ALLAVG}\spxextra{ESMF.api.constants.PoleMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.ALLAVG}}\pysigline{\sphinxbfcode{\sphinxupquote{ALLAVG}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleMethod.ALLAVG: 1\textgreater{}}}}
Construct an artificial pole placed in the center of the top (or bottom)
row of nodes, but projected onto the sphere formed by the rest of the grid.
The value at this pole is the average of all the source values surrounding
the pole.

\end{fulllineitems}

\index{NPNTAVG (ESMF.api.constants.PoleMethod attribute)@\spxentry{NPNTAVG}\spxextra{ESMF.api.constants.PoleMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.NPNTAVG}}\pysigline{\sphinxbfcode{\sphinxupquote{NPNTAVG}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleMethod.NPNTAVG: 2\textgreater{}}}}
Construct an artificial pole placed in the center of the top (or bottom)
row of nodes, but projected onto the sphere formed by the rest of the grid.
The value at this pole is the average of the N source nodes next to the pole
and surrounding the destination point (i.e. the value may differ for each
destination point). Here N is set by using the regridPoleNPnts parameter
and ranges from 1 to the number of nodes around the pole. This option is
useful for interpolating values which may be zeroed out by averaging around
the entire pole (e.g. vector components).

\end{fulllineitems}

\index{TEETH (ESMF.api.constants.PoleMethod attribute)@\spxentry{TEETH}\spxextra{ESMF.api.constants.PoleMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{PoleMethod:ESMF.api.constants.PoleMethod.TEETH}}\pysigline{\sphinxbfcode{\sphinxupquote{TEETH}}\sphinxbfcode{\sphinxupquote{ = \textless{}PoleMethod.TEETH: 3\textgreater{}}}}
No new pole point is constructed, instead the holes at the poles are filled
by constructing triangles across the top and bottom row of the source {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.
This can be useful because no averaging occurs, however, because the top and
bottom of the sphere are now flat, for a big enough mismatch between the
size of the destination and source pole holes, some destination points may
still not be able to be mapped to the source {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Region}
\label{\detokenize{Region:region}}\label{\detokenize{Region::doc}}\index{Region (class in ESMF.api.constants)@\spxentry{Region}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Region:ESMF.api.constants.Region}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{Region}}}
Specify various regions in the data layout of a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} object.
\index{TOTAL (ESMF.api.constants.Region attribute)@\spxentry{TOTAL}\spxextra{ESMF.api.constants.Region attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Region:ESMF.api.constants.Region.TOTAL}}\pysigline{\sphinxbfcode{\sphinxupquote{TOTAL}}\sphinxbfcode{\sphinxupquote{ = \textless{}Region.TOTAL: 0\textgreater{}}}}
An operation applies to every element in the selected domain.

\end{fulllineitems}

\index{SELECT (ESMF.api.constants.Region attribute)@\spxentry{SELECT}\spxextra{ESMF.api.constants.Region attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Region:ESMF.api.constants.Region.SELECT}}\pysigline{\sphinxbfcode{\sphinxupquote{SELECT}}\sphinxbfcode{\sphinxupquote{ = \textless{}Region.SELECT: 1\textgreater{}}}}
An operation applies to a select portion of the domain. One use of this is
to specify that the portions of a {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}} that are not mapped in a regridding
operation should retain their original value (as opposed to being
initialized to 0).

\end{fulllineitems}

\index{EMPTY (ESMF.api.constants.Region attribute)@\spxentry{EMPTY}\spxextra{ESMF.api.constants.Region attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Region:ESMF.api.constants.Region.EMPTY}}\pysigline{\sphinxbfcode{\sphinxupquote{EMPTY}}\sphinxbfcode{\sphinxupquote{ = \textless{}Region.EMPTY: 2\textgreater{}}}}
An operation does not apply any element in the domain.

\end{fulllineitems}


\end{fulllineitems}



\subsection{RegridMethod}
\label{\detokenize{RegridMethod:regridmethod}}\label{\detokenize{RegridMethod::doc}}\index{RegridMethod (class in ESMF.api.constants)@\spxentry{RegridMethod}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{RegridMethod}}}
Specify which interpolation method to use during regridding.
\index{BILINEAR (ESMF.api.constants.RegridMethod attribute)@\spxentry{BILINEAR}\spxextra{ESMF.api.constants.RegridMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.BILINEAR}}\pysigline{\sphinxbfcode{\sphinxupquote{BILINEAR}}\sphinxbfcode{\sphinxupquote{ = \textless{}RegridMethod.BILINEAR: 0\textgreater{}}}}
Bilinear interpolation. Destination value is a linear combination of the 
source values in the cell which contains the destination point. The 
weights for the linear combination are based on the distance of destination 
point from each source value.

\end{fulllineitems}

\index{PATCH (ESMF.api.constants.RegridMethod attribute)@\spxentry{PATCH}\spxextra{ESMF.api.constants.RegridMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.PATCH}}\pysigline{\sphinxbfcode{\sphinxupquote{PATCH}}\sphinxbfcode{\sphinxupquote{ = \textless{}RegridMethod.PATCH: 1\textgreater{}}}}
Higher-order patch recovery interpolation. Destination value is a weighted 
average of 2D polynomial patches constructed from cells surrounding the 
source cell which contains the destination point. This method typically 
results in better approximations to values and derivatives than bilinear. 
However, because of its larger stencil, it also results in a much larger 
interpolation matrix (and thus routeHandle) than the bilinear.

\end{fulllineitems}

\index{CONSERVE (ESMF.api.constants.RegridMethod attribute)@\spxentry{CONSERVE}\spxextra{ESMF.api.constants.RegridMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE}}\pysigline{\sphinxbfcode{\sphinxupquote{CONSERVE}}\sphinxbfcode{\sphinxupquote{ = \textless{}RegridMethod.CONSERVE: 2\textgreater{}}}}
First-order conservative interpolation. The main purpose of this method is 
to preserve the integral of the field between the source and destination. 
Will typically give a less accurate approximation to the individual field 
values than the bilinear or patch methods. The value of a destination cell 
is calculated as the weighted sum of the values of the source cells that it 
overlaps. The weights are determined by the amount the source cell overlaps 
the destination cell. Needs corner coordinate values to be provided in the 
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}. Currently only works for 
{\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} created on the 
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} center stagger or 
the {\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} element location.

\end{fulllineitems}

\index{NEAREST\_STOD (ESMF.api.constants.RegridMethod attribute)@\spxentry{NEAREST\_STOD}\spxextra{ESMF.api.constants.RegridMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.NEAREST_STOD}}\pysigline{\sphinxbfcode{\sphinxupquote{NEAREST\_STOD}}\sphinxbfcode{\sphinxupquote{ = \textless{}RegridMethod.NEAREST\_STOD: 3\textgreater{}}}}
In this version of nearest neighbor interpolation each destination point is 
mapped to the closest source point. A given source point may go to multiple 
destination points, but no destination point will receive input from more 
than one source point.

\end{fulllineitems}

\index{NEAREST\_DTOS (ESMF.api.constants.RegridMethod attribute)@\spxentry{NEAREST\_DTOS}\spxextra{ESMF.api.constants.RegridMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.NEAREST_DTOS}}\pysigline{\sphinxbfcode{\sphinxupquote{NEAREST\_DTOS}}\sphinxbfcode{\sphinxupquote{ = \textless{}RegridMethod.NEAREST\_DTOS: 4\textgreater{}}}}
In this version of nearest neighbor interpolation each source point is 
mapped to the closest destination point. A given destination point may 
receive input from multiple source points, but no source point will go to 
more than one destination point.

\end{fulllineitems}

\index{CONSERVE\_2ND (ESMF.api.constants.RegridMethod attribute)@\spxentry{CONSERVE\_2ND}\spxextra{ESMF.api.constants.RegridMethod attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{RegridMethod:ESMF.api.constants.RegridMethod.CONSERVE_2ND}}\pysigline{\sphinxbfcode{\sphinxupquote{CONSERVE\_2ND}}\sphinxbfcode{\sphinxupquote{ = \textless{}RegridMethod.CONSERVE\_2ND: 5\textgreater{}}}}
Second-order conservative interpolation. As with first-order, preserves the 
integral of the value between the source and destination. However, typically 
produces a smoother more accurate result than first-order. Also like 
first-order, the value of a destination cell is calculated as the weighted 
sum of the values of the source cells that it overlaps. However, 
second-order also includes additional terms to take into account the 
gradient of the field across the source cell. Needs corner coordinate 
values to be provided in the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}}. Currently only 
works for {\hyperref[\detokenize{field:ESMF.api.field.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fields}}}}} created 
on the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} center stagger or the 
{\hyperref[\detokenize{mesh:ESMF.api.mesh.Mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Mesh}}}}} element location.

\end{fulllineitems}


\end{fulllineitems}



\subsection{StaggerLoc}
\label{\detokenize{StaggerLoc:staggerloc}}\label{\detokenize{StaggerLoc::doc}}\index{StaggerLoc (class in ESMF.api.constants)@\spxentry{StaggerLoc}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{StaggerLoc}}}
In the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} class, data can be located at different positions in a
{\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} cell. When setting or retrieving coordinate data the stagger
location is specified to tell the {\hyperref[\detokenize{grid:ESMF.api.grid.Grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Grid}}}}} method from where in the
cell to get the data.
\index{CENTER (ESMF.api.constants.StaggerLoc attribute)@\spxentry{CENTER}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER}}\pysigline{\sphinxbfcode{\sphinxupquote{CENTER}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.CENTER: 0\textgreater{}}}}
2D: Cell centered stagger location.

\end{fulllineitems}

\index{EDGE1 (ESMF.api.constants.StaggerLoc attribute)@\spxentry{EDGE1}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.EDGE1}}\pysigline{\sphinxbfcode{\sphinxupquote{EDGE1}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.EDGE1: 1\textgreater{}}}}
2D: First dimension edge stagger location.

\end{fulllineitems}

\index{EDGE2 (ESMF.api.constants.StaggerLoc attribute)@\spxentry{EDGE2}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.EDGE2}}\pysigline{\sphinxbfcode{\sphinxupquote{EDGE2}}\sphinxbfcode{\sphinxupquote{ = None}}}
2D: Second dimension edge stagger location.

\end{fulllineitems}

\index{CORNER (ESMF.api.constants.StaggerLoc attribute)@\spxentry{CORNER}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CORNER}}\pysigline{\sphinxbfcode{\sphinxupquote{CORNER}}\sphinxbfcode{\sphinxupquote{ = None}}}
2D: Cell corner stagger location.

\end{fulllineitems}

\index{CENTER\_VCENTER (ESMF.api.constants.StaggerLoc attribute)@\spxentry{CENTER\_VCENTER}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VCENTER}}\pysigline{\sphinxbfcode{\sphinxupquote{CENTER\_VCENTER}}\sphinxbfcode{\sphinxupquote{ = None}}}
3D: Vertically centered stagger location.

\end{fulllineitems}

\index{EDGE1\_VCENTER (ESMF.api.constants.StaggerLoc attribute)@\spxentry{EDGE1\_VCENTER}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.EDGE1_VCENTER}}\pysigline{\sphinxbfcode{\sphinxupquote{EDGE1\_VCENTER}}\sphinxbfcode{\sphinxupquote{ = None}}}
3D: Vertically centered first dimension edge stagger location.

\end{fulllineitems}

\index{EDGE2\_VCENTER (ESMF.api.constants.StaggerLoc attribute)@\spxentry{EDGE2\_VCENTER}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.EDGE2_VCENTER}}\pysigline{\sphinxbfcode{\sphinxupquote{EDGE2\_VCENTER}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.EDGE2\_VCENTER: 2\textgreater{}}}}
3D: Vertically centered second dimension edge stagger location.

\end{fulllineitems}

\index{CORNER\_VCENTER (ESMF.api.constants.StaggerLoc attribute)@\spxentry{CORNER\_VCENTER}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CORNER_VCENTER}}\pysigline{\sphinxbfcode{\sphinxupquote{CORNER\_VCENTER}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.CORNER\_VCENTER: 3\textgreater{}}}}
3D: Vertically centered corner stagger location.

\end{fulllineitems}

\index{CENTER\_VFACE (ESMF.api.constants.StaggerLoc attribute)@\spxentry{CENTER\_VFACE}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CENTER_VFACE}}\pysigline{\sphinxbfcode{\sphinxupquote{CENTER\_VFACE}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.CENTER\_VFACE: 4\textgreater{}}}}
3D: Centered stagger location of the top and bottom cell faces.

\end{fulllineitems}

\index{EDGE1\_VFACE (ESMF.api.constants.StaggerLoc attribute)@\spxentry{EDGE1\_VFACE}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.EDGE1_VFACE}}\pysigline{\sphinxbfcode{\sphinxupquote{EDGE1\_VFACE}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.EDGE1\_VFACE: 5\textgreater{}}}}
3D: First dimension edge stagger location of the top and bottom cell faces.

\end{fulllineitems}

\index{EDGE2\_VFACE (ESMF.api.constants.StaggerLoc attribute)@\spxentry{EDGE2\_VFACE}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.EDGE2_VFACE}}\pysigline{\sphinxbfcode{\sphinxupquote{EDGE2\_VFACE}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.EDGE2\_VFACE: 6\textgreater{}}}}
3D: Second dimension edge stagger location of the top and bottom cell faces.

\end{fulllineitems}

\index{CORNER\_VFACE (ESMF.api.constants.StaggerLoc attribute)@\spxentry{CORNER\_VFACE}\spxextra{ESMF.api.constants.StaggerLoc attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{StaggerLoc:ESMF.api.constants.StaggerLoc.CORNER_VFACE}}\pysigline{\sphinxbfcode{\sphinxupquote{CORNER\_VFACE}}\sphinxbfcode{\sphinxupquote{ = \textless{}StaggerLoc.CORNER\_VFACE: 7\textgreater{}}}}
3D: Corner stagger location of the top and bottom cell faces.

\end{fulllineitems}


\end{fulllineitems}



\subsection{TypeKind}
\label{\detokenize{TypeKind:typekind}}\label{\detokenize{TypeKind::doc}}\index{TypeKind (class in ESMF.api.constants)@\spxentry{TypeKind}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{TypeKind:ESMF.api.constants.TypeKind}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{TypeKind}}}
This is used to indicate the type and kind of ESMPy types to the
underlying ESMF library routines.
\index{I4 (ESMF.api.constants.TypeKind attribute)@\spxentry{I4}\spxextra{ESMF.api.constants.TypeKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{TypeKind:ESMF.api.constants.TypeKind.I4}}\pysigline{\sphinxbfcode{\sphinxupquote{I4}}\sphinxbfcode{\sphinxupquote{ = \textless{}TypeKind.I4: 3\textgreater{}}}}
A four byte integer, equivalent to numpy.int32.

\end{fulllineitems}

\index{I8 (ESMF.api.constants.TypeKind attribute)@\spxentry{I8}\spxextra{ESMF.api.constants.TypeKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{TypeKind:ESMF.api.constants.TypeKind.I8}}\pysigline{\sphinxbfcode{\sphinxupquote{I8}}\sphinxbfcode{\sphinxupquote{ = \textless{}TypeKind.I8: 4\textgreater{}}}}
An eight byte integer, equivalent to numpy.int64.

\end{fulllineitems}

\index{R4 (ESMF.api.constants.TypeKind attribute)@\spxentry{R4}\spxextra{ESMF.api.constants.TypeKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{TypeKind:ESMF.api.constants.TypeKind.R4}}\pysigline{\sphinxbfcode{\sphinxupquote{R4}}\sphinxbfcode{\sphinxupquote{ = \textless{}TypeKind.R4: 5\textgreater{}}}}
A four byte real, equivalent to numpy.float32.

\end{fulllineitems}

\index{R8 (ESMF.api.constants.TypeKind attribute)@\spxentry{R8}\spxextra{ESMF.api.constants.TypeKind attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{TypeKind:ESMF.api.constants.TypeKind.R8}}\pysigline{\sphinxbfcode{\sphinxupquote{R8}}\sphinxbfcode{\sphinxupquote{ = \textless{}TypeKind.R8: 6\textgreater{}}}}
An eight byte real, equivalent to numpy.float64.

\end{fulllineitems}


\end{fulllineitems}



\subsection{UnmappedAction}
\label{\detokenize{UnmappedAction:unmappedaction}}\label{\detokenize{UnmappedAction::doc}}\index{UnmappedAction (class in ESMF.api.constants)@\spxentry{UnmappedAction}\spxextra{class in ESMF.api.constants}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ESMF.api.constants.}}\sphinxbfcode{\sphinxupquote{UnmappedAction}}}
This is used to indicate what action to take with respect to unmapped destination
points and the entries of the sparse matrix that correspond to
these points.
\index{ERROR (ESMF.api.constants.UnmappedAction attribute)@\spxentry{ERROR}\spxextra{ESMF.api.constants.UnmappedAction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction.ERROR}}\pysigline{\sphinxbfcode{\sphinxupquote{ERROR}}\sphinxbfcode{\sphinxupquote{ = \textless{}UnmappedAction.ERROR: 0\textgreater{}}}}
Unmapped points result in an error code return.

\end{fulllineitems}

\index{IGNORE (ESMF.api.constants.UnmappedAction attribute)@\spxentry{IGNORE}\spxextra{ESMF.api.constants.UnmappedAction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{UnmappedAction:ESMF.api.constants.UnmappedAction.IGNORE}}\pysigline{\sphinxbfcode{\sphinxupquote{IGNORE}}\sphinxbfcode{\sphinxupquote{ = \textless{}UnmappedAction.IGNORE: 1\textgreater{}}}}
Unmapped points are ignored.

\end{fulllineitems}


\end{fulllineitems}



\section{References}
\label{\detokenize{appendix:references}}

\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{1}
\bibitem[1]{appendix:ref-scrip}
SCRIP: A Spherical Coordinate Remapping and Interpolation Package. http://oceans11.lanl.gov/trac/SCRIP, last accessed on Dec 4, 2015. Los Alamos Software Release LACC 98-45.
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{e}
\item\relax\sphinxstyleindexentry{ESMF}\sphinxstyleindexpageref{intro:\detokenize{module-ESMF}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}